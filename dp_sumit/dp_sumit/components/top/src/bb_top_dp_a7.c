//#################################################################################################
// Icron Technology Corporation - Copyright 2015
//
// This source file and the information contained in it are confidential and proprietary to Icron
// Technology Corporation. The reproduction or disclosure, in whole or in part, to anyone outside
// of Icron without the written approval of a Icron officer under a Non-Disclosure Agreement, or to
// any employee of Icron who has not previously obtained written authorization for access from the
// individual responsible for the source code, will have a significant detrimental effect on Icron
// and is expressly prohibited.
//#################################################################################################

//#################################################################################################
// Module Description
//#################################################################################################
// Implementations of functions common to the Lex and Rex DP subsystems.
//#################################################################################################

//#################################################################################################
// Design Notes
//#################################################################################################
// TODO
//#################################################################################################

#ifdef PLATFORM_A7

// Includes #######################################################################################
#include <bb_core.h>
#include <ibase.h>
#include <bb_chip_regs.h>
#include <bb_top_regs.h> // for GTP/X registers. TODO remove this include and access all GTP/X
                         // functionality through bb_top.h's API
#include <bb_top.h>
#include <bb_top_dp.h>
#include <bb_top_dp_a7.h>

#include <leon_timers.h>
#include <callback.h>
#include <uart.h>
#include "bb_top_log.h"

// Constants and Macros ###########################################################################

// TODO eventually these defines should be grouped into struct arrays for greater clarity.
// GTP DRP addresses, offsets, values, and masks (see Xilinx doc UG476 7 Series GTP/GTH Transceivers
// table 6-8)

#define GTP_DRP_ADDR_RX_DATA_WIDTH 0x11
#define GTP_DRP_OFFSET_RX_DATA_WIDTH 11
#define GTP_DRP_VAL_RX_DATA_WIDTH_40_BIT_PORT (0x5 << GTP_DRP_OFFSET_RX_DATA_WIDTH)
#define GTP_DRP_MASK_RX_DATA_WIDTH (0x7 << GTP_DRP_OFFSET_RX_DATA_WIDTH)

#define GTP_DRP_ADDR_TX_DATA_WIDTH 0x6B
#define GTP_DRP_OFFSET_TX_DATA_WIDTH 0
#define GTP_DRP_VAL_TX_DATA_WIDTH_40_BIT_PORT (0x5 << GTP_DRP_OFFSET_TX_DATA_WIDTH)
#define GTP_DRP_MASK_TX_DATA_WIDTH (0x7 << GTP_DRP_OFFSET_TX_DATA_WIDTH)

#define GTP_DRP_ADDR_PLL0_REFCLK_DIV 0x4
#define GTP_DRP_OFFSET_PLL0_REFCLK_DIV 9
#define GTP_DRP_MASK_PLL0_REFCLK_DIV (0x1F << GTP_DRP_OFFSET_PLL0_REFCLK_DIV)

#define GTP_DRP_ADDR_PLL0_FBDIV_45 0x4
#define GTP_DRP_OFFSET_PLL0_FBDIV_45 7
#define GTP_DRP_MASK_PLL0_FBDIV_45 (0x1 << GTP_DRP_OFFSET_PLL0_FBDIV_45)

#define GTP_DRP_ADDR_PLL0_FBDIV 0x4
#define GTP_DRP_OFFSET_PLL0_FBDIV 0
#define GTP_DRP_MASK_PLL0_FBDIV (0x3F << GTP_DRP_OFFSET_PLL0_FBDIV)

#define GTP_DRP_ADDR_PLL1_REFCLK_DIV 0x2b
#define GTP_DRP_OFFSET_PLL1_REFCLK_DIV 9
#define GTP_DRP_MASK_PLL1_REFCLK_DIV (0x1F << GTP_DRP_OFFSET_PLL1_REFCLK_DIV)

#define GTP_DRP_ADDR_PLL1_FBDIV_45 0x2b
#define GTP_DRP_OFFSET_PLL1_FBDIV_45 7
#define GTP_DRP_MASK_PLL1_FBDIV_45 (0x1 << GTP_DRP_OFFSET_PLL1_FBDIV_45)

#define GTP_DRP_ADDR_PLL1_FBDIV 0x2b
#define GTP_DRP_OFFSET_PLL1_FBDIV 0
#define GTP_DRP_MASK_PLL1_FBDIV (0x3F << GTP_DRP_OFFSET_PLL1_FBDIV)

#define GTP_DRP_ADDR_TXOUT_DIV 0x88
#define GTP_DRP_OFFSET_TXOUT_DIV 4
#define GTP_DRP_MASK_TXOUT_DIV ( 0x7 << GTP_DRP_OFFSET_TXOUT_DIV)

#define GTP_DRP_ADDR_RXOUT_DIV 0x88
#define GTP_DRP_OFFSET_RXOUT_DIV 0
#define GTP_DRP_MASK_RXOUT_DIV ( 0x7 << GTP_DRP_OFFSET_RXOUT_DIV)

#define GTP_DRP_ADDR_RX_CLK25_DIV 0x11
#define GTP_DRP_OFFSET_RX_CLK25_DIV 6
#define GTP_DRP_MASK_RX_CLK25_DIV ( 0x1F << GTP_DRP_OFFSET_RX_CLK25_DIV)

// Note: values for the RXCDR_CFGx registers are generated by Xilinx's CDR wizard, and currently
// just defined in the code.
#define GTP_DRP_ADDR_RXCDR_CFG0 0xA8
#define GTP_DRP_OFFSET_RXCDR_CFG0 0
#define GTP_DRP_MASK_RXCDR_CFG0 0xFFFF
#define GTP_DRP_MASK_RXCDR_CFG  0xFFFF

#define GTP_DRP_ADDR_RXCDR_CFG1 0xA9
#define GTP_DRP_OFFSET_RXCDR_CFG1 0
#define GTP_DRP_MASK_RXCDR_CFG1 0xFFFF

#define GTP_DRP_ADDR_RXCDR_CFG2 0xAA
#define GTP_DRP_OFFSET_RXCDR_CFG2 0
#define GTP_DRP_MASK_RXCDR_CFG2 0xFFFF

#define GTP_DRP_ADDR_RXCDR_CFG3 0xAB
#define GTP_DRP_OFFSET_RXCDR_CFG3 0
#define GTP_DRP_MASK_RXCDR_CFG3 0xFFFF

#define GTP_DRP_ADDR_RXCDR_CFG4 0xAC
#define GTP_DRP_OFFSET_RXCDR_CFG4 0
#define GTP_DRP_MASK_RXCDR_CFG4 0xFFFF

#define GTP_RX_CDR_CFG_SIZE 5
// Data Types #####################################################################################

union GtpBaseAddress
{
    volatile bb_top_dp_gtp_rx *rx;
    volatile bb_top_dp_gtp_tx *tx;
};


// Global Variables ###############################################################################

bool TxDiffCtrl;
bool TxPostCursor;

// Static Variables ###############################################################################
static union GtpBaseAddress gtp;
static volatile bb_top_s* bb_top_registers = (volatile bb_top_s*) bb_chip_bb_top_s_ADDRESS;
static volatile bb_chip_s* bb_chip = (volatile void*)(bb_chip_s_ADDRESS);

struct rxOutClkMmcm
{
    uint8_t addr;
    uint16_t hbr2_40b;
    uint16_t hbr_40b;
    uint16_t rbr_40b;
    uint16_t hbr_20b;
    uint16_t rbr_20b;
};

static const struct txOutClkMmcm mmcmSource[] =
{
    {  0x6, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    {  0x7, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    {  0x8, 0x10C3, 0x1145, 0x1208, 0x1083, 0x1104 },
    {  0x9, 0x0000, 0x0000, 0x0000, 0x0080, 0x0000 },
    {  0xA, 0x1042, 0x1083, 0x1104, 0x1083, 0x1104 },
    {  0xB, 0x0080, 0x0080, 0x0000, 0x0080, 0x0000 },
    {  0xC, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    {  0xD, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    {  0xE, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    {  0xF, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    { 0x10, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    { 0x11, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    { 0x12, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    { 0x13, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    { 0x14, 0x10C3, 0x1083, 0x130C, 0x1083, 0x130C },
    { 0x15, 0x0000, 0x0080, 0x0000, 0x0080, 0x0000 },
    { 0x16, 0x1041, 0x1041, 0x2083, 0x1041, 0x2083 },
    { 0x18, 0x03E8, 0x03E8, 0x0190, 0x03E8, 0x0190 },
    { 0x19, 0x4401, 0x3801, 0x7C01, 0x3801, 0x7C01 },
    { 0x1A, 0x47E9, 0x3BE9, 0x7FE9, 0x3BE9, 0x7FE9 },
    { 0x28, 0x9999, 0x9999, 0x9999, 0x9999, 0x9999 },
    { 0x4E, 0x9808, 0x9108, 0x1108, 0x9108, 0x1108 },
    { 0x4F, 0x8900, 0x1900, 0x9000, 0x9100, 0x9000 }
};

static const struct rxOutClkMmcm mmcmSink[] =
{
    {  0x6, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    {  0x7, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    {  0x8, 0x10C3, 0x1145, 0x1208, 0x1083, 0x1104 },
    {  0x9, 0x0000, 0x0000, 0x0000, 0x0080, 0x0000 },
    {  0xA, 0x1042, 0x1083, 0x1104, 0x1083, 0x1104 },
    {  0xB, 0x0080, 0x0080, 0x0000, 0x0080, 0x0000 },
    {  0xC, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    {  0xD, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    {  0xE, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    {  0xF, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    { 0x10, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    { 0x11, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    { 0x12, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    { 0x13, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040 },
    { 0x14, 0x1042, 0x1083, 0x1104, 0x1083, 0x1104 },
    { 0x15, 0x0080, 0x0080, 0x0000, 0x0080, 0x0000 },
    { 0x16, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041 },
    { 0x18, 0x03E8, 0x03E8, 0x03E8, 0x03E8, 0x03E8 },
    { 0x19, 0x2001, 0x3801, 0x5801, 0x3801, 0x5801 },
    { 0x1A, 0x23E9, 0x3BE9, 0x5BE9, 0x3BE9, 0x5BE9 },
    { 0x28, 0x9999, 0x9999, 0x9999, 0x9999, 0x9999 },
    { 0x4E, 0x1108, 0x9108, 0x9908, 0x9108, 0x9908 },
    { 0x4F, 0x8900, 0x1900, 0x0900, 0x9100, 0x0900 }
};

// SSC On 5.4Gbps setup values
static const uint16_t rxCdrCfgSscOn5G[GTP_RX_CDR_CFG_SIZE] =
{
    0x1010, 0x2448, 0x2060, 0x87FE, 0x0000
};

// SSC On non 5.4Gbps setup values
static const uint16_t rxCdrCfgSscOn[GTP_RX_CDR_CFG_SIZE] =
{
    0x1010, 0x2450, 0x2060, 0x47FE, 0x0000
};

// SSC Off 5.4Gbps setup values
static const uint16_t rxCdrCfgSscOff5G[GTP_RX_CDR_CFG_SIZE] =
{
    0x1010, 0x0104, 0x4060, 0x07FE, 0x0001
};

// SSC Off non 5.4Gbps setup values
static const uint16_t rxCdrCfgSscOff[GTP_RX_CDR_CFG_SIZE] =
{
    0x1010, 0x0104, 0x2060, 0x07FE, 0x0001
};

static const uint8_t numMmcmWritesSource = ARRAYSIZE(mmcmSource);
static const uint8_t numMmcmWritesSink = ARRAYSIZE(mmcmSink);
static struct
{
    enum MainLinkBandwidth bw;
    enum LaneCount lc;
    bb_top_drp_drp_en_mask laneMask;
    LEON_TimerValueT gtpLockStartTime;
    LEON_TimerValueT gtpFrqStartTime;
    void (*gtpConfigureCallback)(bool);
    void (*gtpFrqCallback)(uint32_t);
} bbTopDpCtx;

// Static Function Declarations ###################################################################

static void configureDpTransceiverCommonA7(void);
static void configurePll0(enum MainLinkBandwidth bw);
static void configurePll1(enum MainLinkBandwidth bw);
static void configureSourceSerialClkDiv(
    enum MainLinkBandwidth bw,
    bb_top_drp_drp_en_mask laneMask);
static void configureSinkSerialClkDiv(
    enum MainLinkBandwidth bw,
    bb_top_drp_drp_en_mask laneMask);
static void configureGtTxOutClkMmcm(enum MmcmTxClkOutEncoding encoding);
static void configureGtRxOutClkMmcm(enum MmcmTxClkOutEncoding encoding);
static void configureSourceTxPdMode(uint8_t activeLanes);
static void configureSinkRxPdMode(uint8_t activeLanes);
static void configureSinkRxPolarity(void);
static void configureSourceTxPolarity(void);
static void bb_top_dpConfigureDpTransceiverLexA7_2(void *param1, void *param2);
static void bb_top_dpConfigureDpTransceiverLexA7_3(void *param1, void *param2);
static void bb_top_dpConfigureDpTransceiverLexA7_4(void *param1, void *param2);
static void bb_top_GtpResetCallback(bool success);
static void bb_top_a7_checkDpFreq(void *param1, void *param2);

#ifdef FUTURE_USE
void configureSourceTxPrbsSel(uint8_t activeLanes);
void configureSinkRxPrbsSel(uint8_t activeLanes);
void configureSinkRxPrbsCntRst(uint8_t activeLanes);
#endif

// Exported Function Definitions ##################################################################
//#################################################################################################
// Initialize the pointers.
//
// Parameters:
// Return:
// Assumptions:
//      * This function is expected to be called exactly once during system initialization.
//#################################################################################################
void bb_top_dpInitA7(void)
{
    if (bb_top_IsDeviceLex())
    {
        gtp.rx = (volatile void*) &bb_chip->bb_top.s.dp_gtp_rx.s;
    }
    else
    {
        gtp.tx = (volatile void*) &bb_chip->bb_top.s.dp_gtp_tx.s;
    }
}

//#################################################################################################
// Initializes values for the Displayport transceiver hardware (in this case the GTP) on
// the Lex.
//
// Parameters:
//      bw                  - The bandwidth setting for the transceiver to use.
//      lc                  - The lane count for the transceiver to use.
//  /* LEX LANE MAP
//  * LANE 0 - GT 3
//  * LANE 1 - GT 0
//  * LANE 2 - GT 2
//  * LANE 3 - GT 1
//  */
//  const bb_top_drp_drp_en_mask laneMask = { .bf = {
//     .dp_gt3 = lc == LANE_COUNT_1 || lc == LANE_COUNT_2 || lc == LANE_COUNT_4,
//     .dp_gt0 = lc == LANE_COUNT_2 || lc == LANE_COUNT_4,
//     .dp_gt2 = lc == LANE_COUNT_4,
//     .dp_gt1 = lc == LANE_COUNT_4,
//  }};
// Return:
// Assumptions:
//#################################################################################################
void bb_top_dpInitConfigureDpTransceiverLexA7(enum MainLinkBandwidth bw, enum LaneCount lc)
{
    iassert_TOP_COMPONENT_2(bw == BW_1_62_GBPS || bw == BW_2_70_GBPS || bw == BW_5_40_GBPS,
                           BB_TOP_DP_TRANSCEIVER_CONFIG_VALUE_ERROR, bw, __LINE__);
    iassert_TOP_COMPONENT_2(
            lc != LANE_COUNT_INVALID, BB_TOP_DP_TRANSCEIVER_CONFIG_VALUE_ERROR, lc, __LINE__);

    bbTopDpCtx.bw = bw;
    bbTopDpCtx.lc = lc;
    bbTopDpCtx.laneMask.dw = 0;

    switch(lc)
    {
        case LANE_COUNT_4:
            bbTopDpCtx.laneMask.bf.dp_gt1 = 1;
            bbTopDpCtx.laneMask.bf.dp_gt2 = 1;
        case LANE_COUNT_2:
            bbTopDpCtx.laneMask.bf.dp_gt0 = 1;
        case LANE_COUNT_1:
            bbTopDpCtx.laneMask.bf.dp_gt3 = 1;
            break;
        case LANE_COUNT_INVALID:
        default:
            break;
    }
}

//#################################################################################################
// start configuring the Displayport transceiver hardware (in this case the GTP) on
// the Lex.
//
// Parameters:
// Return:
// Assumptions: It takes about 30us
//              http://lexington/wiki/index.php/BB_A7_Core#DisplayPort_Sink_Transceiver_Setup
//              Callback is also used to check if GTP configuration is cancelled due to state change
//#################################################################################################
void bb_top_dpConfigureDpTransceiverLexA7(void (*callback)(bool))
{
    bbTopDpCtx.gtpConfigureCallback = callback;

    // Put all GTP transceivers in soft reset while they are being configured
    bb_top_applyDpRxSoftReset(true);
    configureDpTransceiverCommonA7();

    configurePll0(bbTopDpCtx.bw);
    configureSinkSerialClkDiv(bbTopDpCtx.bw, bbTopDpCtx.laneMask);

    CALLBACK_Run(bb_top_dpConfigureDpTransceiverLexA7_2, NULL, NULL);
}

//#################################################################################################
// Cancel GTP setup configuration.
//
// Parameters:
// Return:
// Assumptions:
//#################################################################################################
void bb_top_cancelDpConfigureDpTransceiverLexA7(void)
{
    bbTopDpCtx.gtpConfigureCallback = NULL;
}


void bb_top_dpResetDpTransceiverLexA7(void)
{
    // Power down transceivers
    bb_top_setDpGtpRxMiscCtrlPd(DP_GTP_GT0_SYS_LANE_SEL, DP_GTP_TX_RX_PD_MODE_3);
    bb_top_setDpGtpRxMiscCtrlPd(DP_GTP_GT1_SYS_LANE_SEL, DP_GTP_TX_RX_PD_MODE_3);
    bb_top_setDpGtpRxMiscCtrlPd(DP_GTP_GT2_SYS_LANE_SEL, DP_GTP_TX_RX_PD_MODE_3);
    bb_top_setDpGtpRxMiscCtrlPd(DP_GTP_GT3_SYS_LANE_SEL, DP_GTP_TX_RX_PD_MODE_3);

    // Power down GTP CPLLs
    bb_top_applyGtpPllPowerDown(DP_GTP_PLL_CLK_SEL_PLL1, true);
    bb_top_applyGtpPllPowerDown(DP_GTP_PLL_CLK_SEL_PLL0, true);
}


//#################################################################################################
// Initializes and configures the Displayport transceiver hardware (in this case the GTP) on
// the Rex.
//
// Parameters:
//      bw                  - The bandwidth setting for the transceiver to use.
//      lc                  - The lane count for the transceiver to use.
// Return:
// Assumptions:
//#################################################################################################
void bb_top_dpConfigureDpTransceiverRexA7(enum MainLinkBandwidth bw, enum LaneCount lc)
{
    iassert_TOP_COMPONENT_2(bw == BW_1_62_GBPS || bw == BW_2_70_GBPS || bw == BW_5_40_GBPS,
                            BB_TOP_DP_TRANSCEIVER_CONFIG_VALUE_ERROR,
                            bw,
                            __LINE__);
    iassert_TOP_COMPONENT_2(lc != LANE_COUNT_INVALID,
                            BB_TOP_DP_TRANSCEIVER_CONFIG_VALUE_ERROR,
                            lc,
                            __LINE__);
    ilog_TOP_COMPONENT_2(ILOG_MAJOR_EVENT, BB_TOP_DP_INITIALIZING_DP_TRANSCEIVERS, bw, lc);

    /* REX LANE MAP
     * LANE 0 - GT 2
     * LANE 1 - GT 3
     * LANE 2 - GT 0
     * LANE 3 - GT 1
     */
    const bb_top_drp_drp_en_mask laneMask = { .bf = {
        .dp_gt2 = lc == LANE_COUNT_1 || lc == LANE_COUNT_2 || lc == LANE_COUNT_4,
        .dp_gt3 = lc == LANE_COUNT_2 || lc == LANE_COUNT_4,
        .dp_gt0 = lc == LANE_COUNT_4,
        .dp_gt1 = lc == LANE_COUNT_4,
    }};

    // Put all GTP transceivers in soft reset while they are being configured
    bb_top_applyDpTxSoftReset(true);
    configureDpTransceiverCommonA7();
    const enum MmcmTxClkOutEncoding enc = computeMmcmTxClkOutEncoding(bw);

    configurePll1(bw);
    configureSourceSerialClkDiv(bw, laneMask);
    configureGtTxOutClkMmcm(enc);
    configureSourceTxPolarity();
    configureSourceTxPdMode((uint8_t)laneMask.dw);
    //    configureSourceTxPrbsSel(activeLanes);
    bb_top_dpSetVoltageSwingA7();
    bb_top_dpSetPreEmphasisA7();
    // Take all GTP transceivers out of soft reset now that they are configured
    bb_top_applyDpTxSoftReset(false);

    // NOTE: the GTP is not yet out of reset. Any client that wishes to take
    // the DP source out of reset must first wait for the GTP.
    // TODO handle this in a cleaner, more explicit way
}


void bb_top_dpResetDpTransceiverRexA7(void)
{
    // Power down transceivers
    bb_top_setDpGtpTxMiscCtrlPd(DP_GTP_GT0_SYS_LANE_SEL, DP_GTP_TX_RX_PD_MODE_3);
    bb_top_setDpGtpTxMiscCtrlPd(DP_GTP_GT1_SYS_LANE_SEL, DP_GTP_TX_RX_PD_MODE_3);
    bb_top_setDpGtpTxMiscCtrlPd(DP_GTP_GT2_SYS_LANE_SEL, DP_GTP_TX_RX_PD_MODE_3);
    bb_top_setDpGtpTxMiscCtrlPd(DP_GTP_GT3_SYS_LANE_SEL, DP_GTP_TX_RX_PD_MODE_3);

    // Power down GTP CPLLs
    bb_top_applyGtpPllPowerDown(DP_GTP_PLL_CLK_SEL_PLL1, true);
    bb_top_applyGtpPllPowerDown(DP_GTP_PLL_CLK_SEL_PLL0, true);
}


//#################################################################################################
// Check we have Sink (RX) clock lock, if so, remove sink_rst
//
// Parameters:
// Return:
// Assumptions:
//#################################################################################################
void bb_top_dpEnableDpSinkA7(void)
{
    const LEON_TimerValueT startTime = LEON_TimerRead();
    // Wait for the reset to complete
    while (!gtp.rx->rx_status.bf.gt3_rx_fsm_reset_done)
    {
        iassert_TOP_COMPONENT_1(
                LEON_TimerCalcUsecDiff(startTime, LEON_TimerRead()) < GT_RESET_TIMEOUT_USEC,
                BB_TOP_DP_GTP_RESET_TOO_SLOW,
                GT_RESET_TIMEOUT_USEC);
    }

    // Now that the sink has a clock, take it out of reset
    bb_top_ApplyResetDpSink(false);
}


//#################################################################################################
// Check we have Source (TX) clock lock, if so, remove source_rst
//
// Parameters:
// Return:
// Assumptions:
//#################################################################################################
void bb_top_dpEnableDpSourceA7(void)
{
    const LEON_TimerValueT startTime = LEON_TimerRead();
    // Ensure the GTP FSM is out of reset. NOTE: this can take up to 9 ms.
    while (!gtp.tx->tx_status.bf.gt2_tx_fsm_reset_done)
    {
        iassert_TOP_COMPONENT_1(
                LEON_TimerCalcUsecDiff(startTime, LEON_TimerRead()) < GT_RESET_TIMEOUT_USEC,
                BB_TOP_DP_GTP_RESET_TOO_SLOW,
                GT_RESET_TIMEOUT_USEC);
    }
    // Now that the source has a clock, take it out of reset
    bb_top_ApplyResetDpSource(false);
}


//#################################################################################################
// Check if we have clock recovery
//
// Parameters:
// Return:
//          true or false
// Assumptions:
//#################################################################################################
bool bb_top_dpGotClockRecoveryA7(void)
{
    return gtp.rx->rx_status.bf.gt_rxoutclk_mmcm_lock;
}


//#################################################################################################
// Check if we have symbol lock for the specified lane counts
//
// Parameters:
// Return:
//          true or false
// Assumptions:
//#################################################################################################
bool bb_top_dpGotSymbolLockA7(enum LaneCount lc)
{
    // TODO should we make the output of this function more granular (i.e., per-lane)?
    const bb_top_dp_gtp_rx_rx_byte_align_status alignStatus = { .dw = gtp.rx->rx_byte_align_status.dw };
    bool symbolLock =   (lc > 0 ? alignStatus.bf.gt3_rxbyteisaligned : true) &&
                        (lc > 1 ? alignStatus.bf.gt0_rxbyteisaligned : true) &&
                        (lc > 2 ? alignStatus.bf.gt2_rxbyteisaligned : true) &&
                        (lc > 3 ? alignStatus.bf.gt1_rxbyteisaligned : true);

    if(!symbolLock)
    {
        ilog_TOP_COMPONENT_1(ILOG_MAJOR_EVENT, BB_TOP_DP_NO_SYMBOL_LOCK, alignStatus.dw);
    }

    return symbolLock;
}

//#################################################################################################
// Do an RMW of the existing voltage swing values based on laneMask
//
// Parameters:
// Return:
//          true or false
// Assumptions:
// Rex only
// Note: (laneMask & (1 << i)) => we wish to modify the value for lane i
//#################################################################################################
void bb_top_dpSetVoltageSwingA7(void)
{
    // Mapping from DP voltage swing values to their closest matching GTP
    // voltage swing values. For more information see
    // http://lexington/wiki/index.php/BB_KC705#DisplayPort_Transceiver_Setup
    // static const uint8_t dpToGtp[] = { 0x2, 0x6, 0x9, 0xF };

    // Read
    bb_top_dp_gtp_tx_tx_diff_ctrl txDiffCtrl = { .dw = gtp.tx->tx_diff_ctrl.dw };

    if(TxDiffCtrl == true)
    {
        return;
    }
    else
    {
            txDiffCtrl.bf.gt2_txdiffctrl = 0xF;
            txDiffCtrl.bf.gt3_txdiffctrl = 0xF;
            txDiffCtrl.bf.gt0_txdiffctrl = 0xF;
            txDiffCtrl.bf.gt1_txdiffctrl = 0xF;

        gtp.tx->tx_diff_ctrl.dw = txDiffCtrl.dw;
    }

}


//#################################################################################################
// Do an RMW of the existing pre-emphasis values based on laneMask
//
// Parameters:
// Return:
//          true or false
// Assumptions:
// Rex only
// Note: (laneMask & (1 << i)) => we wish to modify the value for lane i
//#################################################################################################
void bb_top_dpSetPreEmphasisA7(void)
{
    // Mapping from DP pre-emphasis values to their closest matching GTP
    // pre-emphasis values. For more information see
    // http://lexington/wiki/index.php/BB_KC705#DisplayPort_Transceiver_Setup
    // static const uint8_t dpToGtp[] = { 0x00, 0x0D, 0x14, 0x1B };

    // Read
    bb_top_dp_gtp_tx_tx_post_cursor txPostCursor = { .dw = gtp.tx->tx_post_cursor.dw };
    if(TxPostCursor == true)
    {
        return;
    }
    else
    {
            txPostCursor.bf.gt2_txpostcursor = 0;
            txPostCursor.bf.gt3_txpostcursor = 0;
            txPostCursor.bf.gt0_txpostcursor = 0;
            txPostCursor.bf.gt1_txpostcursor = 0;
    // Write
        gtp.tx->tx_post_cursor.dw = txPostCursor.dw;
    }
    // ilog_TOP_COMPONENT_2(ILOG_DEBUG, BB_TOP_DP_SET_PREEMPHASIS,
    //         (pe[0] << 0) | (pe[1] << 8) | (pe[2] << 16) | (pe[3] << 24),
    //         txPostCursor.dw);
}


//#################################################################################################
// Do an RMW of the existing pre-charge values based on laneMask
//
// Parameters:
// Return:
//          true or false
// Assumptions:
// Rex only
// Note: (laneMask & (1 << i)) => we wish to modify the value for lane i
//#################################################################################################
void bb_top_dpPreChargeMainLinkA7(bool charge, enum LaneCount lc)
{
    ilog_TOP_COMPONENT_2(ILOG_DEBUG, BB_TOP_DP_PRECHARGE, charge, lc);
    // Read
    bb_top_dp_gtp_tx_tx_misc_ctrl miscCtrl = { .dw = gtp.tx->tx_misc_ctrl.dw };

    // Mod
    if (lc > 0)
    {
        miscCtrl.bf.gt2_txinhibit = charge;
    }
    if (lc > 1)
    {
        miscCtrl.bf.gt3_txinhibit = charge;
    }
    if (lc > 2)
    {
        miscCtrl.bf.gt0_txinhibit = charge;
    }
    if (lc > 3)
    {
        miscCtrl.bf.gt1_txinhibit = charge;
    }
    // Write
    gtp.tx->tx_misc_ctrl.dw = miscCtrl.dw;
}

//#################################################################################################
// To be used in Icmd to set txdiffctrl to desired value
//
// Parameters:
// Return:
//
// Assumptions:
// Rex only
//#################################################################################################
void bb_top_dpSetTxDiffCtrlA7(uint8_t gtTxDiffCtrl, bool changeDiffCtrl)
{
    TxDiffCtrl = changeDiffCtrl;

    bb_top_dp_gtp_tx_tx_diff_ctrl txDiffCtrl = { .dw = gtp.tx->tx_diff_ctrl.dw };

        txDiffCtrl.bf.gt2_txdiffctrl = gtTxDiffCtrl;
        txDiffCtrl.bf.gt3_txdiffctrl = gtTxDiffCtrl;
        txDiffCtrl.bf.gt0_txdiffctrl = gtTxDiffCtrl;
        txDiffCtrl.bf.gt1_txdiffctrl = gtTxDiffCtrl;
    // Write
    gtp.tx->tx_diff_ctrl.dw = txDiffCtrl.dw;
}


//#################################################################################################
// To be used in Icmd to set postcursor to desired value
//
// Parameters:
// Return:
//
// Assumptions:
// Rex only
//#################################################################################################
void bb_top_dpSetTxPostCursorA7(uint8_t gtTxPostCursor, bool changePostCursor)
{
    TxPostCursor = changePostCursor;

     bb_top_dp_gtp_tx_tx_post_cursor txPostCursor = { .dw = gtp.tx->tx_post_cursor.dw };

        txPostCursor.bf.gt2_txpostcursor = gtTxPostCursor;
        txPostCursor.bf.gt3_txpostcursor = gtTxPostCursor;
        txPostCursor.bf.gt0_txpostcursor = gtTxPostCursor;
        txPostCursor.bf.gt1_txpostcursor = gtTxPostCursor;
    // Write
    gtp.tx->tx_post_cursor.dw = txPostCursor.dw;
}


//#################################################################################################
// Get Middle Frequency
// This function is used for SSC detection
// http://10.0.4.24/wiki/index.php/BB_A7_Core#DisplayPort_Transceiver_PLL_Setup
//
// Return:
// Assumptions:
//
//#################################################################################################
void bb_top_a7_getDpFreq(const struct DpFreqCalculate *dpFreqCalculate, void (*callback)(uint32_t))
{
    bool stillRunning = bbTopDpCtx.gtpFrqCallback!=NULL ? false : true;
    iassert_TOP_COMPONENT_0(stillRunning, BB_TOP_FRQ_RUNNING); //Assert if the last callback is not cleared

    bbTopDpCtx.gtpFrqCallback = callback;
    bb_top_registers->gcm.s.freq_det_dp.bf.max_count = dpFreqCalculate->max_count;
    bb_top_registers->gcm.s.freq_det_dp.bf.clk_sel = dpFreqCalculate->clk_sel;
    bb_top_registers->gcm.s.freq_det_dp.bf.go = 1;

    bbTopDpCtx.gtpFrqStartTime = LEON_TimerRead();
    CALLBACK_Run(bb_top_a7_checkDpFreq, NULL, NULL);
}

//#################################################################################################
// This function will set the auto freq detection module
// Parameters:
// Return:
// Assumptions:
//
//#################################################################################################
void bb_top_a7_dp_frq_det_auto(const struct DpFreqDetAuto *dpFreqDetAutoLoad)
{
    bb_top_registers->gcm.s.freq_det_dp.bf.clk_sel = 1; //Select DP_GT_TXUSRCLK2
    bb_top_registers->gcm.s.freq_det_dp_auto.bf.auto_enable = true;
    bb_top_registers->gcm.s.freq_det_dp_auto.bf.comp_count_max = dpFreqDetAutoLoad->comp_max_count;
    bb_top_registers->gcm.s.freq_det_dp_auto.bf.comp_count_min = dpFreqDetAutoLoad->comp_min_count;
    bb_top_registers->irq.s.enable.bf.freq_det_dp_oor = true; //Enable the interrupt
    bb_top_registers->gcm.s.freq_det_dp.bf.go = 1; // Set the go bit to start the freq detection again
}

//#################################################################################################
// Set Gtp RX CDR confguration
//
// http://10.0.4.24/wiki/index.php/BB_A7_Core#DisplayPort_Transceiver_PLL_Setup
//
// Return:
// Assumptions:
//
//#################################################################################################
void bb_top_a7_configRxCdr(bool sscOn)
{
    const uint16_t *rxCdrCfg = sscOn ? (bbTopDpCtx.bw == BW_5_40_GBPS ? rxCdrCfgSscOn5G : rxCdrCfgSscOn) :
                               bbTopDpCtx.bw == BW_5_40_GBPS ? rxCdrCfgSscOff5G : rxCdrCfgSscOff;

    for(uint8_t i = 0; i < GTP_RX_CDR_CFG_SIZE; i++)
    {
        bb_top_drpReadModWrite(GTP_DRP_ADDR_RXCDR_CFG0 + i,
            rxCdrCfg[i], GTP_DRP_MASK_RXCDR_CFG, bbTopDpCtx.laneMask);
    }
}

// Component Scope Function Definitions ###########################################################
//#################################################################################################
//ICMD that resets the DP RX and checks transceiver status
//
// Parameters:
// Return:
// Assumptions:
//#################################################################################################
void bb_top_GtpResetIcmd(void)
{
    bb_top_dpInitConfigureDpTransceiverLexA7(BW_5_40_GBPS, LANE_COUNT_4);
    bb_top_dpConfigureDpTransceiverLexA7(bb_top_GtpResetCallback);
}

//#################################################################################################
//ICMD to configures the Displayport transceiver hardware
//
// Parameters:
// Return:
// Assumptions:
//#################################################################################################
void bb_top_ConfigureDpTransceiverLexIcmd(void)
{
    bb_top_GtpResetIcmd();
}


// Static Function Definitions ####################################################################
//#################################################################################################
// Local function to perform PLL configuration
//
// Parameters:
// Return:
// Assumptions:
//#################################################################################################
static void configureDpTransceiverCommonA7(void)
{
    const enum DpGtpPllCtrlRefClkSel refClkSel = bb_top_IsDeviceLex() ?
        DP_GTP_PLL_CTRL_REF_CLK_SEL_GTREFCLK0 : DP_GTP_PLL_CTRL_REF_CLK_SEL_GTREFCLK1;
    // Disable Power Downs

    if (bb_top_IsDeviceLex())
    {
        bb_top_applyGtpPllPowerDown(DP_GTP_PLL_CLK_SEL_PLL1, true);
        bb_top_applyGtpPllPowerDown(DP_GTP_PLL_CLK_SEL_PLL0, false);
    }
    else
    {
        bb_top_applyGtpPllPowerDown(DP_GTP_PLL_CLK_SEL_PLL1, false);
        bb_top_applyGtpPllPowerDown(DP_GTP_PLL_CLK_SEL_PLL0, true);
    }
    // Set reference clock select
    bb_top_setGtpPllRefClkSel(DP_GTP_PLL_CLK_SEL_PLL0, refClkSel);
    bb_top_setGtpPllRefClkSel(DP_GTP_PLL_CLK_SEL_PLL1, refClkSel);
    // Ensure all transceivers are PLL0 for Sink
    bb_top_setDpGtpRxClkCtrl(DP_GTP_SYS_CLK_SEL_CFG_REF_PLL0_SRC_PLL0);

    // Ensure all transceivers are PLL1 for Source
    bb_top_setDpGtpTxClkCtrl(DP_GTP_SYS_CLK_SEL_CFG_REF_PLL1_SRC_PLL1);

}


//#################################################################################################
// Local function to perform PLL0 configuration
//
// Parameters:
//              bw - main link bandwidth
// Return:
// Assumptions:
//#################################################################################################
static void configurePll0(enum MainLinkBandwidth bw)
{
    const bb_top_drp_drp_en_mask mask = { .bf.dp_gt_common = 1};
    /*
     * fbDiv45 5 - hbr2/hbr
     * fbDiv45 4 - rbr
     * fbDiv 4 hbr2/hbr
     * fbDiv 3 rbr
     */
    // NOTE: the three values written below live at the same address
    const uint16_t refClkDiv = ((bw == BW_1_62_GBPS || bw == BW_2_70_GBPS) ? 16 :
                                 bw == BW_5_40_GBPS ? 0 : 0xFF) << GTP_DRP_OFFSET_PLL0_REFCLK_DIV;

    const uint16_t fbDiv45 = 1 << GTP_DRP_OFFSET_PLL0_FBDIV_45;

    const uint16_t fbDiv = 2 << GTP_DRP_OFFSET_PLL0_FBDIV;

    iassert_TOP_COMPONENT_2(refClkDiv != (0xFF << GTP_DRP_OFFSET_PLL0_FBDIV_45),
                           BB_TOP_DP_INVALID_BANDWIDTH,
                           bw,
                           __LINE__);
    bb_top_drpReadModWrite(GTP_DRP_ADDR_PLL0_REFCLK_DIV,
                    refClkDiv | fbDiv45 | fbDiv,
                    GTP_DRP_MASK_PLL0_REFCLK_DIV
                    | GTP_DRP_MASK_PLL0_FBDIV_45
                    | GTP_DRP_MASK_PLL0_FBDIV,
                    mask);
}


//#################################################################################################
// Local function to perform PLL1 configuration
//
// Parameters:
//              bw - main link bandwidth
// Return:
// Assumptions:
//#################################################################################################
static void configurePll1(enum MainLinkBandwidth bw)
{
    const bb_top_drp_drp_en_mask mask = { .bf.dp_gt_common = 1};
/*
 * fbDiv45 5 - hbr2/hbr
 * fbDiv45 4 - rbr
 * fbDiv 4 hbr2/hbr
 * fbDiv 3 rbr
*/
    // NOTE: the three values written below live at the same address
    const uint16_t refClkDiv = 16 << GTP_DRP_OFFSET_PLL1_REFCLK_DIV;

    const uint16_t fbDiv45 = (bw == BW_1_62_GBPS ? 0 :
                             (bw == BW_2_70_GBPS || bw == BW_5_40_GBPS) ? 1 : 0xff)
                                << GTP_DRP_OFFSET_PLL1_FBDIV_45;

    const uint16_t fbDiv = (bw == BW_1_62_GBPS ? 1 :
                           (bw == BW_2_70_GBPS || bw == BW_5_40_GBPS) ? 2 : 0xff)
                                << GTP_DRP_OFFSET_PLL1_FBDIV;

    iassert_TOP_COMPONENT_2(fbDiv45 != (0xff << GTP_DRP_OFFSET_PLL1_FBDIV_45) &&
                           fbDiv != (0xff << GTP_DRP_OFFSET_PLL1_FBDIV),
                           BB_TOP_DP_INVALID_BANDWIDTH,
                           bw,
                           __LINE__);
    bb_top_drpReadModWrite(GTP_DRP_ADDR_PLL1_REFCLK_DIV,
                    refClkDiv | fbDiv45 | fbDiv,
                    GTP_DRP_MASK_PLL1_REFCLK_DIV
                    | GTP_DRP_MASK_PLL1_FBDIV_45
                    | GTP_DRP_MASK_PLL1_FBDIV,
                    mask);
}


//#################################################################################################
// Local function to intialize the serial clock devider
//
// Parameters:
//              bw - main link bandwidth
//              laneMask - which lanes (binary) to be set
// Return:
// Assumptions:
//#################################################################################################
static void configureSourceSerialClkDiv(
    enum MainLinkBandwidth bw,
    bb_top_drp_drp_en_mask laneMask)
{
    // NOTE: the two values written below live at the same address
    const uint16_t txOutDiv = (bw == BW_5_40_GBPS ? 0 : 1) << GTP_DRP_OFFSET_TXOUT_DIV;
    bb_top_drpReadModWrite(GTP_DRP_ADDR_TXOUT_DIV,
                    txOutDiv,
                    GTP_DRP_MASK_TXOUT_DIV,
                    laneMask);

    const uint16_t txDataWidth = GTP_DRP_VAL_TX_DATA_WIDTH_40_BIT_PORT;

    bb_top_drpReadModWrite(GTP_DRP_ADDR_TX_DATA_WIDTH,
                    txDataWidth,
                    GTP_DRP_MASK_TX_DATA_WIDTH,
                    laneMask);
}


//#################################################################################################
// Local function to intialize the serial clock devider
//
// Parameters:
//              bw - main link bandwidth
//              laneMask - which lanes (binary) to be set
// Return:
// Assumptions:
//#################################################################################################
static void configureSinkSerialClkDiv(
    enum MainLinkBandwidth bw,
    bb_top_drp_drp_en_mask laneMask)
{
    // NOTE: the two values written below live at the same address
    const uint16_t rxOutDiv = (bw == BW_5_40_GBPS ? 0 : 1) << GTP_DRP_OFFSET_RXOUT_DIV;
    bb_top_drpReadModWrite(GTP_DRP_ADDR_RXOUT_DIV,
                    rxOutDiv,
                    GTP_DRP_MASK_RXOUT_DIV,
                    laneMask);

    const uint16_t rxDataWidth = GTP_DRP_VAL_RX_DATA_WIDTH_40_BIT_PORT;
    bb_top_drpReadModWrite(GTP_DRP_ADDR_RX_DATA_WIDTH,
                    rxDataWidth,
                    GTP_DRP_MASK_RX_DATA_WIDTH,
                    laneMask);

    const uint16_t rxClkDiv = (bw == BW_5_40_GBPS ? 11 : bw == BW_2_70_GBPS ? 6 : 4) << GTP_DRP_OFFSET_RX_CLK25_DIV;
    bb_top_drpReadModWrite(GTP_DRP_ADDR_RX_CLK25_DIV,
                    rxClkDiv,
                    GTP_DRP_MASK_RX_CLK25_DIV,
                    laneMask);    
}


//#################################################################################################
// Local function to power down TX lanes
//
// Parameters:
//              activeLanes - lanes set to 1 are powered down
// Return:
// Assumptions:
//#################################################################################################
static void configureSourceTxPdMode(uint8_t activeLanes)
{
    uint8_t lane = 0;
    for (lane = 0; lane < 4; lane++)
    {
        if ((1 << lane) & activeLanes)
        {
            bb_top_setDpGtpTxMiscCtrlPd(lane, DP_GTP_TX_RX_PD_MODE_0);
        }
        else
        {
            bb_top_setDpGtpTxMiscCtrlPd(lane, DP_GTP_TX_RX_PD_MODE_3);
        }
    }
}


//#################################################################################################
// Local function to configure TX polarity
//
// Parameters:
//              activeLanes - lanes set to 1 are configured
// Return:
// Assumptions:
//#################################################################################################
static void configureSourceTxPolarity(void)
{
    // the default dp_gtp_tx->tx_misc_ctrl->gtx_txpolarity is 0
    if(bb_top_getCoreBoardRev() >= BOM_23_00200_A03)
    {
        bb_top_setDpGtpTxMiscCtrlPolarity(true);
    }
}


//#################################################################################################
// Local function to configure RX polarity
//
// Parameters:
//              activeLanes - lanes set to 1 are configured
// Return:
// Assumptions:
//#################################################################################################
static void configureSinkRxPolarity(void)
{
    // the default dp_gtp_tx->tx_misc_ctrl->gtx_txpolarity is 0
    bb_top_setDpGtpRxMiscCtrlPolarity(true);

}


//#################################################################################################
// Local function to power down RX lanes
//
// Parameters:
//              activeLanes - lanes set to 1 are powered down
// Return:
// Assumptions:
//#################################################################################################
static void configureSinkRxPdMode(uint8_t activeLanes)
{
    uint8_t lane = 0;
    for (lane = 0; lane < 4; lane++)
    {
        if ((1 << lane) & activeLanes)
        {
            bb_top_setDpGtpRxMiscCtrlPd(lane, DP_GTP_TX_RX_PD_MODE_0);
        }
        else
        {
            bb_top_setDpGtpRxMiscCtrlPd(lane, DP_GTP_TX_RX_PD_MODE_3);
        }
    }
}

#ifdef FUTURE_USE
static void configureSourceTxPrbsSel(uint8_t activeLanes)
{
    uint8_t lane = 0;
    for (lane = 0; lane < 4; lane++)
    {
        if ((1 << lane) & activeLanes)
        {
            bb_top_setDpGtpTxPrbsCtrlSel(lane, DP_GTP_TX_RX_PRBS_7);
        }
    }
}

static void configureSourceRxPrbsSel(uint8_t activeLanes)
{
    uint8_t lane = 0;
    for (lane = 0; lane < 4; lane++)
    {
        if ((1 << lane) & activeLanes)
        {
            bb_top_setDpGtpRxPrbsCtrlSel(lane, DP_GTP_TX_RX_PRBS_7);
        }
    }
}

static void configureSourceRxPrbsCntRst(uint8_t activeLanes)
{
    uint8_t lane = 0;
    for (lane = 0; lane < 4; lane++)
    {
        if ((1 << lane) & activeLanes)
        {
            bb_top_applyDpGtpRxPrbsCtrlPrbsCntReset(lane, false);
        }
    }
}
#endif


//#################################################################################################
// Local function to set the TX Clk MMCM
//
// Parameters:
//              enc - frequency to use for given lane width
// Return:
// Assumptions:
//#################################################################################################
static void configureGtTxOutClkMmcm(enum MmcmTxClkOutEncoding encoding)
{
    const bb_top_drp_drp_en_mask mask = { .bf.dp_gt_txoutclk_mmcm = 1};
    uint16_t mmcmValue = 0;
    uint8_t mmcmWrites = 0;
    for (mmcmWrites = 0; mmcmWrites < numMmcmWritesSource; mmcmWrites++)
    {
        switch (encoding)
        {
            case MMCM_TX_CLK_OUT_ENCODING_RBR_40B:
                mmcmValue = mmcmSource[mmcmWrites].rbr_40b;
                break;
            case MMCM_TX_CLK_OUT_ENCODING_HBR_40B:
                mmcmValue = mmcmSource[mmcmWrites].hbr_40b;
                break;
            case MMCM_TX_CLK_OUT_ENCODING_HBR2_40B:
                mmcmValue = mmcmSource[mmcmWrites].hbr2_40b;
                break;
            default:
                break;
        }
        // Write Data Mask is same as Read Data Mask
        bb_top_drpReadModWrite(mmcmSource[mmcmWrites].addr,
            mmcmValue,
            BB_TOP_DRP_DRP_READ_DATA_DRP_DO_MASK,
            mask);
    }
}


//#################################################################################################
// Local function to set the RX Clk MMCM
//
// Parameters:
//              enc - frequency to use for given lane width
// Return:
// Assumptions:
//#################################################################################################
static void configureGtRxOutClkMmcm(enum MmcmTxClkOutEncoding encoding)
{
    const bb_top_drp_drp_en_mask mask = { .bf.dp_gt_rxoutclk_mmcm = 1};
    uint16_t mmcmValue = 0;
    uint8_t mmcmWrites = 0;
    for (mmcmWrites = 0; mmcmWrites < numMmcmWritesSink; mmcmWrites++)
    {
        switch (encoding)
        {
            case MMCM_TX_CLK_OUT_ENCODING_RBR_40B:
                mmcmValue = mmcmSink[mmcmWrites].rbr_40b;
                break;
            case MMCM_TX_CLK_OUT_ENCODING_HBR_40B:
                mmcmValue = mmcmSink[mmcmWrites].hbr_40b;
                break;
            case MMCM_TX_CLK_OUT_ENCODING_HBR2_40B:
                mmcmValue = mmcmSink[mmcmWrites].hbr2_40b;
                break;
            default:
                break;
        }
        // Write Data Mask is same as Read Data Mask
        bb_top_drpReadModWrite(mmcmSink[mmcmWrites].addr,
            mmcmValue,
            BB_TOP_DRP_DRP_READ_DATA_DRP_DO_MASK,
            mask);
    }
}


//#################################################################################################
// 2nd phase GTP setup
//
// Parameters:
// Return:
// Assumptions: It takes about 95us
//              http://lexington/wiki/index.php/BB_A7_Core#DisplayPort_Sink_Transceiver_Setup
//#################################################################################################
static void bb_top_dpConfigureDpTransceiverLexA7_2(void *param1, void *param2)
{
    if(bbTopDpCtx.gtpConfigureCallback)
    {
        const enum MmcmTxClkOutEncoding enc = computeMmcmTxClkOutEncoding(bbTopDpCtx.bw);
        configureGtRxOutClkMmcm(enc);

        CALLBACK_Run(bb_top_dpConfigureDpTransceiverLexA7_3, NULL, NULL);
    }
}

//#################################################################################################
// 3rd phase GTP setup
//
// Parameters:
// Return:
// Assumptions: It takes about 50us
//              http://lexington/wiki/index.php/BB_A7_Core#DisplayPort_Sink_Transceiver_Setup
//#################################################################################################
static void bb_top_dpConfigureDpTransceiverLexA7_3(void *param1, void *param2)
{
    if(bbTopDpCtx.gtpConfigureCallback)
    {
        bb_top_a7_configRxCdr(false);
        configureSinkRxPolarity();
        configureSinkRxPdMode((uint8_t)bbTopDpCtx.laneMask.dw);

        // Take all GTP transceivers out of soft reset now that they are configured
        bb_top_applyDpRxSoftReset(false);

        bbTopDpCtx.gtpLockStartTime = LEON_TimerRead();    // save start time after release GTP reset
        CALLBACK_Run(bb_top_dpConfigureDpTransceiverLexA7_4, NULL, NULL);
    }
}


//#################################################################################################
// 4th phase GTP setup
// Wait until we get GTP lock
//
// Parameters:
// Return:
// Assumptions: It takes about 640us. Wait maximum 1ms
//              callback shouldn't be NULL
//#################################################################################################
static void bb_top_dpConfigureDpTransceiverLexA7_4(void *param1, void *param2)
{
    if(bbTopDpCtx.gtpConfigureCallback)
    {
        if(bb_top_dpGotClockRecoveryA7())
        {
            ilog_TOP_COMPONENT_1(ILOG_MAJOR_EVENT, BB_TOP_DP_MMCM_LOCK, LEON_TimerCalcUsecDiff(bbTopDpCtx.gtpLockStartTime, LEON_TimerRead()));
            bbTopDpCtx.gtpConfigureCallback(true);
        }
        else
        {
            if(LEON_TimerCalcUsecDiff(bbTopDpCtx.gtpLockStartTime, LEON_TimerRead()) < GT_LOCK_TIMEOUT_USEC)
            {
                CALLBACK_Run(bb_top_dpConfigureDpTransceiverLexA7_4, NULL, NULL);
            }
            else
            {
                bbTopDpCtx.gtpConfigureCallback(false);
            }
        }
    }
}

//#################################################################################################
// GTP Reset Icommand callback
//
// Parameters: success represent lock information. (ignore here)
// Return:
// Assumptions:
//
//#################################################################################################
static void bb_top_GtpResetCallback(bool success)
{
    LEON_TimerWaitMicroSec(GT_RESET_TIMEOUT_USEC);

    if(!gtp.rx->rx_status.bf.gt3_rx_fsm_reset_done)
    {
        ilog_TOP_COMPONENT_1(ILOG_MAJOR_EVENT, BB_TOP_DP_GTP_RESET_TOO_SLOW, GT_RESET_TIMEOUT_USEC);
    }
    else
    {
        ilog_TOP_COMPONENT_0(ILOG_MAJOR_EVENT, BB_TOP_GTP_OUT_OF_RESET);
    }
}

//#################################################################################################
// GTP Reset Icommand callback
//
// Parameters: success represent lock information. (ignore here)
// Return:
// Assumptions:
//
//#################################################################################################
static void bb_top_a7_checkDpFreq(void *param1, void *param2)
{
    if(bb_top_a7_hasGcmFrequencyDetectionCompleted(true))
    {
        ilog_TOP_COMPONENT_2(ILOG_MAJOR_EVENT, BB_TOP_DP_FRQ, LEON_TimerCalcUsecDiff(bbTopDpCtx.gtpFrqStartTime, LEON_TimerRead()),
                            bb_top_registers->gcm.s.freq_det_dp.bf.count);

        if(bbTopDpCtx.gtpFrqCallback)
        {
            bbTopDpCtx.gtpFrqCallback(bb_top_registers->gcm.s.freq_det_dp.bf.count);
            bbTopDpCtx.gtpFrqCallback = NULL; // Clear the callback to make sure this routine is completed
        }
    }
    else
    {
        if(LEON_TimerCalcUsecDiff(bbTopDpCtx.gtpFrqStartTime, LEON_TimerRead()) < GT_FRQ_TIMEOUT_USEC)
        {
            CALLBACK_Run(bb_top_a7_checkDpFreq, NULL, NULL);
        }
        else
        {
            bbTopDpCtx.gtpFrqCallback(bb_top_registers->gcm.s.freq_det_dp.bf.count);
        }
    }
}

#endif // PLATFORM_A7
