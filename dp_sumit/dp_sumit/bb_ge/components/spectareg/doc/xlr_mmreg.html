<!--
**********************************************************
 Generated by SpectaReg from PDTi (www.productive-eda.com)
 SpectaReg Revision: 579
 Generated from ViewFileTemplate at: comp_mmreg.html.gen
 ViewFileTemplate Revision: 1057
 Generation date: Wed Aug 29 20:38:00 GMT 2012
**********************************************************
-->

<!--
**************************************************************************
Confidential & Proprietary Property of Productivity Design Tools Inc. (PDTi).
Copyright (c) Productivity Design Tools Inc. (PDTi) 2006, 2007, 2008. All rights reserved.
**************************************************************************
**************************************************************************
*********** THIS FILE GENERATED BY SPECTAGEN - DO NOT EDIT ***************
**************************************************************************
**************************************************************************
**************************************************************************
-->


<html>
<!--
     ***********************************************************************
     Component: XLR
     ***********************************************************************
-->
	<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>XLR Component's Memory Mapped Registers</title>
		<link rel="stylesheet" type="text/css" href="comp_mmreg.css">
	</head>
	<body>
	<h2>XLR Component's Memory Mapped Registers</h2>
	<h3><a name="Register_Summary">Register Summary</a></h3>
	<table class="registerSummary">
		<thead>
		<tr>
			<th>Offset</th>
			<th>Register Name</th>
			<th>R/W</th>
			<th>Reset Value (hex)</th>
		</tr>
		</thead>
		<tbody>
						<tr class="abRow">
			  			<td colspan="4">XLR</td>
						</tr>
						<tr>
			  			<td>0x20000400</td>
			  			<td><a href="#XLR.Id-0x20000400">Id</a></td>
			  			<td>R</td>
			  			<td>5F584C52</td>
						</tr>
						<tr>
			  			<td>0x20000404</td>
			  			<td><a href="#XLR.Rev-0x20000404">Rev</a></td>
			  			<td>R</td>
			  			<td>0000010C</td>
						</tr>
						<tr>
			  			<td>0x20000408</td>
			  			<td><a href="#XLR.IntEn-0x20000408">IntEn</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x2000040C</td>
			  			<td><a href="#XLR.IntFlg-0x2000040C">IntFlg</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000410</td>
			  			<td><a href="#XLR.IntSrc-0x20000410">IntSrc</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000414</td>
			  			<td><a href="#XLR.IntClr-0x20000414">IntClr</a></td>
			  			<td>WO</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000418</td>
			  			<td><a href="#XLR.StatCntIn-0x20000418">StatCntIn</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x2000041C</td>
			  			<td><a href="#XLR.StatCntOut-0x2000041C">StatCntOut</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000420</td>
			  			<td><a href="#XLR.StatCntFlc-0x20000420">StatCntFlc</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000424</td>
			  			<td><a href="#XLR.StatCntErr-0x20000424">StatCntErr</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000428</td>
			  			<td><a href="#XLR.LexCtrl-0x20000428">LexCtrl</a></td>
			  			<td>RW</td>
			  			<td>25000000</td>
						</tr>
						<tr>
			  			<td>0x2000042C</td>
			  			<td><a href="#XLR.RexQSel-0x2000042C">RexQSel</a></td>
			  			<td>RW</td>
			  			<td>00000399</td>
						</tr>
						<tr class="abRow">
			  			<td colspan="4">XMST</td>
						</tr>
						<tr>
			  			<td>0x20000440</td>
			  			<td><a href="#XMST.Control-0x20000440">Control</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000444</td>
			  			<td><a href="#XMST.Rstatus-0x20000444">Rstatus</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000448</td>
			  			<td><a href="#XMST.MidAllo-0x20000448">MidAllo</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>


	</tbody>
	</table>

	<h3>Register Descriptions</h3>
	<!--
		**********************************************************************
	 	Description of the Id Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.Id-0x20000400">Id</a></h3>
	<p class="text">Offset: 0x20000400</p>
	<p class="text">XLR registers ASCII identification register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31:0</td>
		  				<td><p>Id[31:0]</p></td>
		  				<td>
								<p>XLR registers ASCII identification field.</p>

							</td>
		  				<td>R</td>
		  				<td>_XLR</td>
		  				<td>ascii</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the Rev Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.Rev-0x20000404">Rev</a></h3>
	<p class="text">Offset: 0x20000404</p>
	<p class="text"></p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:16</td>
		  				<td class="nameCol">RESERVED_BITS31_16</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>15:8</td>
		  				<td><p>CvsMajor[7:0]</p></td>
		  				<td>
								<p>XLR registers CVS major revision field.  This field relates to the pre-decimal CVS version number, as seen in the format: MAJOR.MINOR</p>

							</td>
		  				<td>R</td>
		  				<td>1</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>7:0</td>
		  				<td><p>CvsMinor[7:0]</p></td>
		  				<td>
								<p>XLR registers CVS minor revision field.  This field relates to the post-decimal CVS version number, as seen in the format: MAJOR.MINOR</p>

							</td>
		  				<td>R</td>
		  				<td>13</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntEn Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.IntEn-0x20000408">IntEn</a></h3>
	<p class="text">Offset: 0x20000408</p>
	<p class="text">Interrupt enable register.<br/><br/>0 = interrupt disabled.<br/>1 = interrupt enabled.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:12</td>
		  				<td class="nameCol">RESERVED_BITS31_12</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>Irq1StatCntErrOverflow</p></td>
		  				<td>
								<p>XLR.StatCntErr.XXXOvfl(s)=1 interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10</td>
		  				<td><p>Irq1StatCntFlcOverflow</p></td>
		  				<td>
								<p>XLR.StatCntFlc.XXXOvfl(s)=1 interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>Irq1StatCntOutOverflow</p></td>
		  				<td>
								<p>XLR.StatCntOut.XXXOvfl(s)=1 interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>Irq1StatCntInOverflow</p></td>
		  				<td>
								<p>XLR.StatCntIn.XXXOvfl(s)=1 interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">7:5</td>
		  				<td class="nameCol">RESERVED_BITS7_5</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>Irq0LexRlsFifoUflow</p></td>
		  				<td>
								<p>LEX release FIFO underflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>Irq0LexRlsFifoOflow</p></td>
		  				<td>
								<p>LEX release FIFO overflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>Irq0LexRty0Rty1</p></td>
		  				<td>
								<p>DQID and Rty0 and Rty1 release collision interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>Irq0LexRty1</p></td>
		  				<td>
								<p>DQID and Rty1 release collision interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>Irq0LexRty0</p></td>
		  				<td>
								<p>DQID and Rty0 release collision interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntFlg Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.IntFlg-0x2000040C">IntFlg</a></h3>
	<p class="text">Offset: 0x2000040C</p>
	<p class="text">Interrupt flag register.<br/><br/>0 = no interrupt event detected<br/>1 = interrupt event detected<br/><br/>Note: if the corresponding interrupt enable field (XLR.IntEn.xxx) is asserted and the corresponding interrupt source field (XLR.IntSrc.xxx) is asserted the interrupt flag will assert.  Unless otherwise stated.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:12</td>
		  				<td class="nameCol">RESERVED_BITS31_12</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>Irq1StatCntErrOverflow</p></td>
		  				<td>
								<p>XLR.StatCntErr.XXXOvfl(s)=1 interrupt flag field.<br/><br/>POSEDGE INTERRUPT: <br/>This field is set on the rising edge of the corresponding interrupt source field when the corresponding interrupt enable field is set.  This field is cleared by writing the corresponding interrupt clear field '1'.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10</td>
		  				<td><p>Irq1StatCntFlcOverflow</p></td>
		  				<td>
								<p>XLR.StatCntFlc.XXXOvfl(s)=1 interrupt flag field.<br/><br/>POSEDGE INTERRUPT: <br/>This field is set on the rising edge of the corresponding interrupt source field when the corresponding interrupt enable field is set.  This field is cleared by writing the corresponding interrupt clear field '1'.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>Irq1StatCntOutOverflow</p></td>
		  				<td>
								<p>XLR.StatCntOut.XXXOvfl(s)=1 interrupt flag field. <br/><br/>POSEDGE INTERRUPT: <br/>This field is set on the rising edge of the corresponding interrupt source field when the corresponding interrupt enable field is set.  This field is cleared by writing the corresponding interrupt clear field '1'.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>Irq1StatCntInOverflow</p></td>
		  				<td>
								<p>XLR.StatCntIn.XXXOvfl(s)=1 interrupt flag field.<br/><br/>POSEDGE INTERRUPT: <br/>This field is set on the rising edge of the corresponding interrupt source field when the corresponding interrupt enable field is set.  This field is cleared by writing the corresponding interrupt clear field '1'.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">7:5</td>
		  				<td class="nameCol">RESERVED_BITS7_5</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>Irq0LexRlsFifoUflow</p></td>
		  				<td>
								<p>LEX release FIFO underflow interrupt flag field.  <br/><br/>POSEDGE INTERRUPT: <br/>This field is set on the rising edge of the corresponding interrupt source field when the corresponding interrupt enable field is set.  This field is cleared by writing the corresponding interrupt clear field '1'.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>Irq0LexRlsFifoOflow</p></td>
		  				<td>
								<p>LEX release FIFO overflow interrupt flag field.<br/><br/>POSEDGE INTERRUPT: <br/>This field is set on the rising edge of the corresponding interrupt source field when the corresponding interrupt enable field is set.  This field is cleared by writing the corresponding interrupt clear field '1'.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>Irq0LexRty0Rty1</p></td>
		  				<td>
								<p>DQID and Rty0 and Rty1 release collision interrupt flag field.<br/><br/>POSEDGE INTERRUPT: <br/>This field is set on the rising edge of the corresponding interrupt source field when the corresponding interrupt enable field is set.  This field is cleared by writing the corresponding interrupt clear field '1'.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>Irq0LexRty1</p></td>
		  				<td>
								<p>DQID and Rty1 release collision interrupt flag field.<br/><br/>POSEDGE INTERRUPT: <br/>This field is set on the rising edge of the corresponding interrupt source field when the corresponding interrupt enable field is set.  This field is cleared by writing the corresponding interrupt clear field '1'.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>Irq0LexRty0</p></td>
		  				<td>
								<p>DQID and Rty0 release collision interrupt flag field.<br/><br/>POSEDGE INTERRUPT: <br/>This field is set on the rising edge of the corresponding interrupt source field when the corresponding interrupt enable field is set.  This field is cleared by writing the corresponding interrupt clear field '1'.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntSrc Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.IntSrc-0x20000410">IntSrc</a></h3>
	<p class="text">Offset: 0x20000410</p>
	<p class="text">Interrupt source register.  <br/><br/>0 = interrupt source inactive.<br/>1 = interrupt source active.<br/><br/>Note: These fields reflect the live interrupt source status and may not be valuable as polled fields.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:12</td>
		  				<td class="nameCol">RESERVED_BITS31_12</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>Irq1StatCntErrOverflow</p></td>
		  				<td>
								<p>XLR.StatCntErr.XXXOvfl(s)=1 interrupt source field.  This field indicates that one or more of the overflow(s) in the XLR.StatCntErr register is = 1.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10</td>
		  				<td><p>Irq1StatCntFlcOverflow</p></td>
		  				<td>
								<p>XLR.StatCntFlc.XXXOvfl(s)=1 interrupt source field.  This field indicates that one or more of the overflow(s) in the XLR.StatCntFlc register is = 1.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>Irq1StatCntOutOverflow</p></td>
		  				<td>
								<p>XLR.StatCntOut.XXXOvfl(s)=1 interrupt source field.  This field indicates that one or more of the overflow(s) in the XLR.StatCntOut register is = 1.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>Irq1StatCntInOverflow</p></td>
		  				<td>
								<p>XLR.StatCntIn.XXXOvfl(s)=1 interrupt source field.  This field indicates that one or more of the overflow(s) in the XLR.StatCntIn register is = 1.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">7:5</td>
		  				<td class="nameCol">RESERVED_BITS7_5</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>Irq0LexRlsFifoUflow</p></td>
		  				<td>
								<p>LEX release FIFO underflow interrupt source field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>Irq0LexRlsFifoOflow</p></td>
		  				<td>
								<p>LEX release FIFO overflow interrupt source field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>Irq0LexRty0Rty1</p></td>
		  				<td>
								<p>DQID and Rty0 and Rty1 release collision interrupt source field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>Irq0LexRty1</p></td>
		  				<td>
								<p>DQID and Rty1 release collision interrupt source field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>Irq0LexRty0</p></td>
		  				<td>
								<p>DQID and Rty0 release collision interrupt source field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntClr Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.IntClr-0x20000414">IntClr</a></h3>
	<p class="text">Offset: 0x20000414</p>
	<p class="text">Interrupt clear register.  Writing '1' to a field within this register will clear the corresponding interrupt flag field in the XUSB.IntFlg register.<br/><br/>Note: All fields within this register are self clearing.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:12</td>
		  				<td class="nameCol">RESERVED_BITS31_12</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>Irq1StatCntErrOverflow</p></td>
		  				<td>
								<p>XLR.StatCntErr.XXXOvfl(s)=1 interrupt clear field.  <br/><br/>Note: Write '1' to this field to clear the corresponding interrupt flag.  This field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10</td>
		  				<td><p>Irq1StatCntFlcOverflow</p></td>
		  				<td>
								<p>XLR.StatCntFlc.XXXOvfl(s)=1 interrupt clear field. <br/><br/>Note: Write '1' to this field to clear the corresponding interrupt flag.  This field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>Irq1StatCntOutOverflow</p></td>
		  				<td>
								<p>XLR.StatCntOut.XXXOvfl(s)=1 interrupt clear field.<br/><br/>Note: Write '1' to this field to clear the corresponding interrupt flag.  This field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>Irq1StatCntInOverflow</p></td>
		  				<td>
								<p>XLR.StatCntIn.XXXOvfl(s)=1 interrupt clear field. <br/><br/>Note: Write '1' to this field to clear the corresponding interrupt flag.  This field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">7:5</td>
		  				<td class="nameCol">RESERVED_BITS7_5</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>Irq0LexRlsFifoUflow</p></td>
		  				<td>
								<p>LEX release FIFO underflow interrupt clear field.  <br/><br/>Note: Write '1' to this field to clear the corresponding interrupt flag.  This field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>Irq0LexRlsFifoOflow</p></td>
		  				<td>
								<p>LEX release FIFO overflow interrupt clear field.<br/><br/>Note: Write '1' to this field to clear the corresponding interrupt flag.  This field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>Irq0LexRty0Rty1</p></td>
		  				<td>
								<p>DQID and Rty0 and Rty1 release collision interrupt clear field.<br/><br/>Note: Write '1' to this field to clear the corresponding interrupt flag.  This field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>Irq0LexRty1</p></td>
		  				<td>
								<p>DQID and Rty1 release collision interrupt clear field.<br/><br/>Note: Write '1' to this field to clear the corresponding interrupt flag.  This field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>Irq0LexRty0</p></td>
		  				<td>
								<p>DQID and Rty0 release collision interrupt clear field.<br/><br/>Note: Write '1' to this field to clear the corresponding interrupt flag.  This field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the StatCntIn Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.StatCntIn-0x20000418">StatCntIn</a></h3>
	<p class="text">Offset: 0x20000418</p>
	<p class="text">IN transaction statistics counter register.<br/><br/>Note: all fields within this register are cleared upon read of this register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>CtrlOvfl</p></td>
		  				<td>
								<p>Control IN transaction counter overflow field.<br/><br/>0 = XUSB.StatCntIn.Ctrl counter has not overflowed.<br/>1 = XUSB.StatCntIn.Ctrl counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>30:25</td>
		  				<td><p>Ctrl[5:0]</p></td>
		  				<td>
								<p>Control IN counter field.  This field is incremented every time it has been determined that a Control IN transaction has completed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>24</td>
		  				<td><p>IntrpOvfl</p></td>
		  				<td>
								<p>Interrupt IN transaction counter overflow field.<br/><br/>0 = XUSB.StatCntIn.Intrp counter has not overflowed.<br/>1 = XUSB.StatCntIn.Intrp counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>23:18</td>
		  				<td><p>Intrp[5:0]</p></td>
		  				<td>
								<p>Interrupt IN counter field.  This field is incremented every time it has been determined that a Interrupt IN transaction has completed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>17</td>
		  				<td><p>IsoOvfl</p></td>
		  				<td>
								<p>Isochronous IN transaction counter overflow field.<br/><br/>0 = XUSB.StatCntIn.Iso counter has not overflowed.<br/>1 = XUSB.StatCntIn.Iso counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>16:9</td>
		  				<td><p>Iso[7:0]</p></td>
		  				<td>
								<p>Isochronous IN counter field.  This field is incremented every time it has been determined that a Isochronous IN transaction has completed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>BulkOvfl</p></td>
		  				<td>
								<p>Bulk IN transaction counter overflow field.<br/><br/>0 = XUSB.StatCntIn.Bulk counter has not overflowed.<br/>1 = XUSB.StatCntIn.Bulk counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>7:0</td>
		  				<td><p>Bulk[7:0]</p></td>
		  				<td>
								<p>Bulk IN counter field.  This field is incremented every time it has been determined that a Bulk IN transaction has completed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the StatCntOut Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.StatCntOut-0x2000041C">StatCntOut</a></h3>
	<p class="text">Offset: 0x2000041C</p>
	<p class="text">OUT transaction statistics counter register.<br/><br/>Note: all fields within this register are cleared upon read of this register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>CtrlOvfl</p></td>
		  				<td>
								<p>Control OUT transaction counter overflow field.<br/><br/>0 = XUSB.StatCntOut.Ctrl counter has not overflowed.<br/>1 = XUSB.StatCntOut.Ctrl counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>30:25</td>
		  				<td><p>Ctrl[5:0]</p></td>
		  				<td>
								<p>Control OUT counter field.  This field is incremented every time it has been determined that a Control OUT transaction has completed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>24</td>
		  				<td><p>IntrpOvfl</p></td>
		  				<td>
								<p>Interrupt OUT transaction counter overflow field.<br/><br/>0 = XUSB.StatCntOut.Intrp counter has not overflowed.<br/>1 = XUSB.StatCntOut.Intrp counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>23:18</td>
		  				<td><p>Intrp[5:0]</p></td>
		  				<td>
								<p>Interrupt OUT counter field.  This field is incremented every time it has been determined that a Interrupt OUT transaction has completed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>17</td>
		  				<td><p>IsoOvfl</p></td>
		  				<td>
								<p>Isochronous OUT transaction counter overflow field.<br/><br/>0 = XUSB.StatCntOut.Iso counter has not overflowed.<br/>1 = XUSB.StatCntOut.Iso counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>16:9</td>
		  				<td><p>Iso[7:0]</p></td>
		  				<td>
								<p>Isochronous OUT counter field.  This field is incremented every time it has been determined that a Isochronous OUT transaction has completed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>BulkOvfl</p></td>
		  				<td>
								<p>Bulk OUT transaction counter overflow field.<br/><br/>0 = XUSB.StatCntOut.Bulk counter has not overflowed.<br/>1 = XUSB.StatCntOut.Bulk counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>7:0</td>
		  				<td><p>Bulk[7:0]</p></td>
		  				<td>
								<p>Bulk OUT counter field.  This field is incremented every time it has been determined that a Bulk OUT transaction has completed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the StatCntFlc Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.StatCntFlc-0x20000420">StatCntFlc</a></h3>
	<p class="text">Offset: 0x20000420</p>
	<p class="text">IN/OUT transaction flow control statistics counter register.<br/><br/>Note: all fields within this register are cleared upon read of this register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:16</td>
		  				<td class="nameCol">RESERVED_BITS31_16</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>15</td>
		  				<td><p>IsoOutOvfl</p></td>
		  				<td>
								<p>Isochronous OUT transaction flow control counter overflow field.<br/><br/>0 = XUSB.StatCntFlc.IsoOut counter has not overflowed.<br/>1 = XUSB.StatCntFlc.IsoOut counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>14:12</td>
		  				<td><p>IsoOut[2:0]</p></td>
		  				<td>
								<p>Isochronous OUT transaction flow control counter field.  This field is incremented every time it has been determined that a Isochronous OUT transaction has been dropped due to flow control conditions.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>BulkOutOvfl</p></td>
		  				<td>
								<p>Bulk OUT transaction flow control counter overflow field.<br/><br/>0 = XUSB.StatCntFlc.BulkOut counter has not overflowed.<br/>1 = XUSB.StatCntFlc.BulkOut counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10:8</td>
		  				<td><p>BulkOut[2:0]</p></td>
		  				<td>
								<p>Bulk OUT transaction flow control counter field.  This field is incremented every time it has been determined that a Bulk OUT transaction has been dropped due to flow control conditions.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>IsoInOvfl</p></td>
		  				<td>
								<p>Isochronous IN transaction flow control counter overflow field.<br/><br/>0 = XUSB.StatCntFlc.IsoIn counter has not overflowed.<br/>1 = XUSB.StatCntFlc.IsoIn counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6:4</td>
		  				<td><p>IsoIn[2:0]</p></td>
		  				<td>
								<p>Isochronous IN transaction flow control counter field.  This field is incremented every time it has been determined that a Isochronous IN transaction has been dropped due to flow control conditions.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>BulkInOvfl</p></td>
		  				<td>
								<p>Bulk IN transaction flow control counter overflow field.<br/><br/>0 = XUSB.StatCntFlc.BulkIn counter has not overflowed.<br/>1 = XUSB.StatCntFlc.BulkIn counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2:0</td>
		  				<td><p>BulkIn[2:0]</p></td>
		  				<td>
								<p>Bulk IN transaction flow control counter field.  This field is incremented every time it has been determined that a Bulk IN transaction has been dropped due to flow control conditions.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the StatCntErr Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.StatCntErr-0x20000424">StatCntErr</a></h3>
	<p class="text">Offset: 0x20000424</p>
	<p class="text">Error statistics counter register.<br/><br/>Note: all fields within this register are cleared upon read of this register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:30</td>
		  				<td class="nameCol">RESERVED_BITS31_30</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>29</td>
		  				<td><p>BabelOvfl</p></td>
		  				<td>
								<p>Babel error counter overflow field.<br/><br/>0 = XUSB.StatCntErr.Babel counter has not overflowed.<br/>1 = XUSB.StatCntErr.Babel counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>28:25</td>
		  				<td><p>Babel[3:0]</p></td>
		  				<td>
								<p>Babel error counter field.  This field is incremented every time it has been determined that a babel error has occurred.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>24</td>
		  				<td><p>BitStuffOvfl</p></td>
		  				<td>
								<p>Bit stuff error counter overflow field.<br/><br/>0 = XUSB.StatCntErr.BitStuff counter has not overflowed.<br/>1 = XUSB.StatCntErr.BitStuff counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>23:20</td>
		  				<td><p>BitStuff[3:0]</p></td>
		  				<td>
								<p>Bit stuff error counter field.  This field is incremented every time it has been determined that a bit stuff error has occurred.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>19</td>
		  				<td><p>PidOvfl</p></td>
		  				<td>
								<p>PID error counter overflow field.<br/><br/>0 = XUSB.StatCntErr.Pid counter has not overflowed.<br/>1 = XUSB.StatCntErr.Pid counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>18:15</td>
		  				<td><p>Pid[3:0]</p></td>
		  				<td>
								<p>PID error counter field.  This field is incremented every time it has been determined that a PID error has occurred.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>14</td>
		  				<td><p>Crc5Ovfl</p></td>
		  				<td>
								<p>CRC5 error counter overflow field.<br/><br/>0 = XUSB.StatCntErr.Crc5 counter has not overflowed.<br/>1 = XUSB.StatCntErr.Crc5 counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>13:10</td>
		  				<td><p>Crc5[3:0]</p></td>
		  				<td>
								<p>CRC5 error counter field.  This field is incremented every time it has been determined that a CRC5 error has occurred.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>Crc16Ovfl</p></td>
		  				<td>
								<p>CRC16 error counter overflow field.<br/><br/>0 = XUSB.StatCntErr.Crc16 counter has not overflowed.<br/>1 = XUSB.StatCntErr.Crc16 counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8:5</td>
		  				<td><p>Crc16[3:0]</p></td>
		  				<td>
								<p>CRC16 error counter field.  This field is incremented every time it has been determined that a CRC16 error has occurred.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>LinkOvfl</p></td>
		  				<td>
								<p>Link error counter overflow field.<br/><br/>0 = XUSB.StatCntErr.Link counter has not overflowed.<br/>1 = XUSB.StatCntErr.Link counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3:0</td>
		  				<td><p>Link[3:0]</p></td>
		  				<td>
								<p>Link error counter field.  This field is incremented every time it has been determined that a Link error has occurred.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the LexCtrl Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.LexCtrl-0x20000428">LexCtrl</a></h3>
	<p class="text">Offset: 0x20000428</p>
	<p class="text">LEX control register.<br/><br/>Note: fields in this register apply only to LEX configurations.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>Enable</p></td>
		  				<td>
								<p>LEX enable field.<br/><br/>0 = LEX disabled.<br/>1 = LEX enabled.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>30</td>
		  				<td><p>FwdSetupsToCpu</p></td>
		  				<td>
								<p>Non-CSPLIT Setup request destination QID selection field.  When set this field will force all Non-CSPLIT setup requests to the CPU_CTRL_QID.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>29</td>
		  				<td><p>FwdSofDnstrm</p></td>
		  				<td>
								<p>This bit allows the LEX to forward all SOF's downstream.  If set all SOF's are forwarded downstream.  If cleared all SOF's are dropped.</p>

							</td>
		  				<td>RW</td>
		  				<td>1</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>28:27</td>
		  				<td><p>Testmode[1:0]</p></td>
		  				<td>
								<p>LEX testmode selection and enable field.<br/><br/>00 = normal LEX operation mode.<br/><br/>01 = LEX system software sets this field when the host sends the USB request: SET_FEATURE - TEST_MODE - TEST_PACKET.  Before writing this field = "01" software must first request a QID from the system cache and then write the USB 2.0 defined test packet into the cache at the requested QID.  Software will then write the QID it requested into the TestmodeQid[6:0] field.<br/><br/>10 = LEX system software sets this field when the host sends the USB request: SET_FEATURE - TEST_MODE - TEST_SE0_NAK.  Selection of this mode will cause the LEX to respond to and only to valid IN transactions with a NAK. The LEX will not forward anything to the REX, and all other traffic will be dropped and not responded to.<br/><br/>11 = reserved.</p>

							</td>
		  				<td>RW</td>
		  				<td>00</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>26</td>
		  				<td><p>CtrlPKtTglChkEn</p></td>
		  				<td>
								<p>This bit is used to check to toggles bits of control packets.  If set and the toggles don't match the LEX hardware will through out the packet and release the Q.</p>

							</td>
		  				<td>RW</td>
		  				<td>1</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">25</td>
		  				<td class="nameCol">RESERVED_BIT25</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>24</td>
		  				<td><p>ThrottleSel</p></td>
		  				<td>
								<p>When this bit is set the LEX will only allow an agregate BULK OUT byte count of < 1024 bytes to be forwarded per micro frame.  All calculations are done at the end of the transaction and therefore actually byte counts on the link may be greater but still less than three 512 byte packets.<br/><br/>When this bit is cleared the rate will be < 512 bytes.  The same caveats apply as for the 1024 byte setting.</p>

							</td>
		  				<td>RW</td>
		  				<td>1</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>23</td>
		  				<td><p>ThrottleBulk</p></td>
		  				<td>
								<p>Enabling this bit will only allow two IN transactions and either 1024bytes or 512Bytes of out data to be forwarded downstream per micro frame.  This applies globally across all endpoints.<br/><br/>There will not be anymore than 2 BULK IN transactions forwarded to the REX in any given micro frame.<br/><br/>For BULK packets, the total number of bytes for each forwarded packet is accumulated within the micro frame.  At the end of the transmission of the last packet if the byte count (this includes the PID and 2CRC bytes) is greater or equal to the limit (either 1024 or 512 as selected by ThrottleSel bit in this register)<br/><br/>*Note that if 3 packets of 300 bytes were forwarded and then a 515 byte packet (PID+CRC16) was sent from the host, then the total sent over the pipe would be 900 + 515 bytes = 1415 bytes.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>22:16</td>
		  				<td><p>TestModeQID[6:0]</p></td>
		  				<td>
								<p>Testmode QID field.  For TEST+PACKET testmode this QID contains the USB I/F test packet.</p>

							</td>
		  				<td>RW</td>
		  				<td>00</td>
		  				<td>hexadecimal</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">15</td>
		  				<td class="nameCol">RESERVED_BIT15</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>14</td>
		  				<td><p>RlsSts</p></td>
		  				<td>
								<p>This bit indicates that the release was ignored by hardware because there is an endpoint currently using the value in the retry buffer.  This is valid one clock after the release bit was set.  If cleared then the release was successful, if set it failed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>13</td>
		  				<td><p>RlsRty0</p></td>
		  				<td>
								<p>Release retry buffer 0 request field.<br/><br/>Note: field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>12</td>
		  				<td><p>RlsRty1</p></td>
		  				<td>
								<p>Release retry buffer 1 request field.<br/><br/>Note: field is self-clearing.</p>

							</td>
		  				<td>WO</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>

        	  	<td>11:10</td>
		  				<td><p>lexCtrlSel[1:0]</p></td>
		  				<td>
								<p>  This field is used to generate different behaviors overides over the entire operation of the LEX.<br/><br/>00 =  No global overides<br/>01 = Must only with MSA endpoints if software wants to manage the ClearFeatureEndPointHalt() support.  This will prevent CFEPH from doing MST lookups.<br/>1x = reserved</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>hexadecimal</td>
					</tr>
        		<tr>
        	  	<td>9:8</td>
		  				<td><p>oNtfyMax[1:0]</p></td>
		  				<td>
								<p>This field indicates the maximum number of packets notifications that are or may have been for any OUT endpoints starting at system reset.  It is updated strictly on the initial XSST read for any transaction.  This information is used strictly for profiling the LEX notification characteristics.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>hexadecimal</td>
					</tr>
        		<tr>
        	  	<td>7:0</td>
		  				<td><p>iNtfyMax[7:0]</p></td>
		  				<td>
								<p>This field indicates the maximum number of packets notifications that are or may have been for any IN endpoints starting at system reset.  It is updated strictly on the initial XSST read for any transaction.  This information is used strictly for profiling the LEX notification characteristics.</p>

							</td>
		  				<td>R</td>
		  				<td>00</td>
		  				<td>hexadecimal</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>


	<!--
		**********************************************************************
	 	Description of the LexCtrl Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XLR.RexQSel-0x2000042C">RexQSel</a></h3>
	<p class="text">Offset: 0x2000042C</p>
	<p class="text">Rex Q selection register.<br/><br/> </p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>

        	  	<td class="bitsCol">31:10</td>
		  				<td class="nameCol">RESERVED_BIT31_10</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td >
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>9:0</td>
		  				<td><p>Qsel</p></td>
		  				<td>
								<p>Description:
								  <br><pre>This logic will determine the downstream<br>Q destination for each of the transaction<br>types listed in the table below.<pre/>
								    <br> Bit is 0 then Alt0 Q is selected<br> Bit is 1 then Alt1 Q is selected
								    <br>HA = Hard Scheduled ASYNC<br>SP = Soft Scheduled Periodic<br>SA = Soft Scheduled ASYNC<br>SM = Soft Scheduled MSA
								  <pre>
								    <br>| MOD | INSTR | EP | Alt0 | Alt1 | Bit |<br>|     |       |    |  Q   |  Q   |     |<br>+=====+=======+====+======+======+=====+
								    <br>| NULL|  IN   |CTRL|  HA  |  SA  |  0  |<br>| NULL|  OUT  |CTRL|  HA  |  SA  |  0  |<br>| NULL|  SETUP|CTRL|  HA  |  SA  |  0  |<br>| NULL|  PING |CTRL|  HA  |  SA  |  0  |
								    <br>| NULL|  IN   |BULK|  HA  |  SA  |  1  |<br>| NULL|  OUT  |BULK|  HA  |  SA  |  1  |<br>| NULL|  PING |BULK|  HA  |  SA  |  1  |
								    <br>| NULL|  IN   | INT|  HA  |  SA  |  2  |<br>| NULL|  OUT  | INT|  HA  |  SA  |  2  |<br>| NULL|  PING | INT|  HA  |  SA  |  2  |
								    <br>| NULL|  IN   |ISOC|  SP  |  HA  |  3  |<br>| NULL|  OUT  |ISOC|  SP  |  HA  |  3  |
								    <br>|SPLIT|  SETUP|CTRL|  SA  |  HA  |  4  |<br>|SPLIT|  IN   |CTRL|  HA  |  SA  |  5  |<br>|SPLIT|  OUT  |CTRL|  HA  |  SA  |  5  |
								    <br>|SPLIT|  IN   |BULK|  HA  |  SA  |  6  |<br>|SPLIT|  OUT  |BULK|  HA  |  SA  |  6  |
								    <br>|SPLIT|  OUT  | INT|  SP  |  HA  |  7  |<br>|SPLIT|  IN   | INT|  SP  |  HA  |  7  |
								    <br>|SPLIT|  OUT  |ISOC|  SP  |  HA  |  8  |<br>|SPLIT|  IN   |ISOC|  SP  |  HA  |  8  |
								    <br>| NULL|  IN   | MSA|  SM  |  HA  |  9  |<br>| NULL|  OUT  | MSA|  SM  |  HA  |  9  |<br>| NULL|  PING | MSA|  SM  |  HA  |  9  |
								  </pre>
								</p>

							</td>
		  				<td>RW</td>
		  				<td>399</td>
		  				<td>hexadecimal</td>
					</tr>
						<tr>
			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>



	<!--
		**********************************************************************
	 	Description of the Control Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XMST.Control-0x20000440">Control</a></h3>
	<p class="text">Offset: 0x20000440</p>
	<p class="text">XSST control register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:26</td>
		  				<td class="nameCol">RESERVED_BITS31_26</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>25:23</td>
		  				<td><p>Wmask[2:0]</p></td>
		  				<td>
								<p>XMST write status mask field.  This field is only required for XMST read-modify-write accesses. Set bits '1' to allow modification for that bit location.</p>

							</td>
		  				<td>RW</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>22:18</td>
		  				<td><p>Wstatus[4:0]</p></td>
		  				<td>
								<p>XMST write data/status field.<br/><br/>Based on XMST.Control.AccMode this field is set accordingly:<br/><br/>RD LAT/MPT/MST - [04:00] = 5'bXXXXX<br/>WR/RMW MST     - [04:03] = 2'bXX,  [02:00] = MST status<br/>WR MPT         - [04]    = 1'bX,   [03:00] = MID (MST index)<br/>WR LAT         - [04]    = Enable, [03:00] = Logical Address</p>

							</td>
		  				<td>RW</td>
		  				<td>00000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>17</td>
		  				<td><p>InSsn</p></td>
		  				<td>
								<p>Last read in-session bit field.  Following a XMST read this bit will be set if the address endpoint being read is currently held in session by another XMST interface.  This will represent a high likelihood that the value read is about to be modified by another interface.  Note this field is not valid following an XMST write or XMST read-modify-write.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>16:10</td>
		  				<td><p>DevAddr[6:0]</p></td>
		  				<td>
								<p>USB device address field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>9:6</td>
		  				<td><p>DevEndpt[3:0]</p></td>
		  				<td>
								<p>USB device endpoint field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>5:3</td>
		  				<td><p>AccMode[2:0]</p></td>
		  				<td>
								<p>XMST access mode selection field.<br/><br/>LAT = logical address table (contains enable and logical address)<br/>MPT = pointer table (contains MID)<br/>MST = status table (contains status)<br/><br/>0000 : RD  - LAT & MPT & MST<br/>0001 : WR  - MST <br/>0010 : WR  - MPT<br/>0011 : WR  - LAT<br/>0100 : RMW - MST<br/>other: RESERVED (do not attempt)<br/><br/>NOTE: (reads) a read access will provide the LAT and MPT rdata as well as the MST rstatus.<br/><br/>NOTE: (writes) a write access requires that the Wmask and Wdata bit fields be set appropriately when setting the GO field.<br/> <br/>NOTE: (read-modify-writes) a read-modify-write access will provide the LAT and MPT rdata as well as the pre-modified MST status.  Like writes, the Wmask and Wdata bit fields be set appropriately when setting the GO field.</p>

							</td>
		  				<td>RW</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>Go</p></td>
		  				<td>
								<p>XMST transaction GO field.  Write '1' to initiate the transaction selected by XMST.Control.AccMode.<br/><br/>Note: for write and read-modify-write access ensure wdata and wmask fields set appropriately when setting this field.<br/><br/>Note: this field is automatically cleared upon completion of the transaction.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>InitDone</p></td>
		  				<td>
								<p>XMST initialization complete field.  This field is set '1' upon completion of initializing the XMST tables.  This field is cleared '0' while a XMST.Control.Clear is performed.  This signal is used to clear the XMST.Control.Clear upon completion of an XMST clear.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>Clear</p></td>
		  				<td>
								<p>XMST clear request field.  Write '1' to re-initialize in all tables within the XMST.   <br/><br/>Note: Initialized tables contain all zeros.<br/>Note: This field is automatically cleared upon initialization of all tables.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the Rstatus Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XMST.Rstatus-0x20000444">Rstatus</a></h3>
	<p class="text">Offset: 0x20000444</p>
	<p class="text">XSST read status most significant word register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:12</td>
		  				<td class="nameCol">RESERVED_BITS31_12</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>MsaEn</p></td>
		  				<td>
								<p>Mass Storage Acceleration enabled field.  This field is updated with the mass storage acceleration enabled field for the USB device accessed following a read or read-modify-write XMST transaction.  <br/><br/>Note: this field is not updated following a write transaction.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10:7</td>
		  				<td><p>LatRdata[3:0]</p></td>
		  				<td>
								<p>Logical address field for USB device accessed.  This field is updated with the logical address for the USB device accessed following a read or read-modify-write XMST transaction.  <br/><br/>Note: this field is not updated following a write transaction.</p>

							</td>
		  				<td>R</td>
		  				<td>0000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6:3</td>
		  				<td><p>MptRdata[3:0]</p></td>
		  				<td>
								<p>Mass storage status pointer table index.   This field is updated with the mass storage status pointer table index (MID) for the USB device accessed following a read or read-modify-write XMST transaction.  <br/><br/>Note: this field is not updated following a write transaction.</p>

							</td>
		  				<td>R</td>
		  				<td>0000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2:0</td>
		  				<td><p>MstRstatus[2:0]</p></td>
		  				<td>
								<p>MSA_MST read status field. This field is updated following a read or read-modify-write XSST transaction.  However, for a read-modify-write this field will reflect the pre-modified value.  <br/><br/>Note: this field is not updated following a write transaction.</p>

							</td>
		  				<td>R</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MidAllo Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="XMST.MidAllo-0x20000448">MidAllo</a></h3>
	<p class="text">Offset: 0x20000448</p>
	<p class="text">XSST_MSA Mass Storage Index allocation/deallocation control register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:17</td>
		  				<td class="nameCol">RESERVED_BITS31_17</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>16:12</td>
		  				<td><p>FreeIDcnt[4:0]</p></td>
		  				<td>
								<p>Mass Storage Index free count field.  Represents remaining MIDs.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>IDerr</p></td>
		  				<td>
								<p>MID (de)allocation error status field.  This field is asserted when a new MID request occurs while the queue (de)allocation FIFO is empty or when a return MID request occurs with a RetQueue that has not yet been allocated.  <br/><br/>0 = no MID (de)allocation error detected.<br/>1 = MID (de)allocation error detected.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10:7</td>
		  				<td><p>NewID[3:0]</p></td>
		  				<td>
								<p>New MID request result field.  This field is the result of a new MID request, and is valid once the asserted XSST.MidAllo.Go field is clear.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>NewIDreq</p></td>
		  				<td>
								<p>New MID request field.  When this field is set '1' the XSST.MidAllo.RetIDreq field is ignored.  A NewIDreq has higher priority.  <br/><br/>0 = no new MID request.<br/>1 = new MID request.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5:2</td>
		  				<td><p>RetID[3:0]</p></td>
		  				<td>
								<p>Return MID field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>RetIDreq</p></td>
		  				<td>
								<p>Return MID request field.  When the XSST.MidAllo.NewQReq field is set '1' this field is ignored.  A NewIDreq has higher priority.  <br/><br/>0 = no return MID request.<br/>1 = return MID request.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>Go</p></td>
		  				<td>
								<p>XICS_MSA MID (de)allocation transaction GO field.  Write '1' to initiate a transaction.  <br/><br/>Note: for a RetIDreq transactions ensure that RetID field is set appropriately before or while asserting this field.<br/>Note: this field is automatically cleared upon completion of the transaction.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<table class="footer">
	<tr>
		<td><p>XLR Memory Mapped Registers</p></td>
		<td><p align="center">&copy;2009 Productivity Design Tools Inc. (PDTi)</p></td>
		<td><p align="right">Generated using <a href="http://www.productive-eda.com">PDTi</a> SpectaReg.</p></td>
	</tr>
	</table>
	</body>
</html>
