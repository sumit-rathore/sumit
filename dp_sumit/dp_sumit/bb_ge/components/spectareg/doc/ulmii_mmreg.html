<!--
**********************************************************
 Generated by SpectaReg from PDTi (www.productive-eda.com)
 SpectaReg Revision: 579
 Generated from ViewFileTemplate at: comp_mmreg.html.gen
 ViewFileTemplate Revision: 1057
 Generation date: Wed Jan 25 19:44:29 GMT 2012
**********************************************************
-->

<!--
**************************************************************************
Confidential & Proprietary Property of Productivity Design Tools Inc. (PDTi).
Copyright (c) Productivity Design Tools Inc. (PDTi) 2006, 2007, 2008. All rights reserved.
**************************************************************************
**************************************************************************
*********** THIS FILE GENERATED BY SPECTAGEN - DO NOT EDIT ***************
**************************************************************************
**************************************************************************
**************************************************************************
-->


<html>
<!--
     ***********************************************************************
     Component: ULMII
     ***********************************************************************
-->
	<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>ULMII Component's Memory Mapped Registers</title>
		<link rel="stylesheet" type="text/css" href="comp_mmreg.css">
	</head>
	<body>
	<h2>ULMII Component's Memory Mapped Registers</h2>
	<h3><a name="Register_Summary">Register Summary</a></h3>
	<table class="registerSummary">
		<thead>
		<tr>
			<th>Offset</th>
			<th>Register Name</th>
			<th>R/W</th>
			<th>Reset Value (hex)</th>
		</tr>
		</thead>
		<tbody>
						<tr class="abRow">
			  			<td colspan="4">ULMII</td>
						</tr>
						<tr>
			  			<td>0x20000100</td>
			  			<td><a href="#ULMII.Id-0x20000100">Id</a></td>
			  			<td>R</td>
			  			<td>554C4D32</td>
						</tr>
						<tr>
			  			<td>0x20000104</td>
			  			<td><a href="#ULMII.Rev-0x20000104">Rev</a></td>
			  			<td>R</td>
			  			<td>0000010d</td>
						</tr>
						<tr>
			  			<td>0x20000108</td>
			  			<td><a href="#ULMII.CnfgSts-0x20000108">CnfgSts</a></td>
			  			<td>RW</td>
			  			<td>0001308C</td>
						</tr>
						<tr>
			  			<td>0x2000010C</td>
			  			<td><a href="#ULMII.Ctrl-0x2000010C">Ctrl</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000110</td>
			  			<td><a href="#ULMII.IntSrc-0x20000110">IntSrc</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000114</td>
			  			<td><a href="#ULMII.IntEn-0x20000114">IntEn</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000118</td>
			  			<td><a href="#ULMII.IntFlag-0x20000118">IntFlag</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000120</td>
			  			<td><a href="#ULMII.PhySts-0x20000120">PhySts</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000128</td>
			  			<td><a href="#ULMII.UlpiAccess-0x20000128">UlpiAccess</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						<tr>
						</tr>
			  			<td>0x2000012C</td>
			  			<td><a href="#ULMII.PhyDbg0-0x2000012C">PhyDbg0</a></td>
			  			<td>RW</td>
			  			<td>00000104</td>
						</tr>
						<tr>
			  			<td>0x20000130</td>
			  			<td><a href="#ULMII.IpgTmrLs-0x20000130">IpgTmrLs</a></td>
			  			<td>RW</td>
			  			<td>62BF3F3F</td>
						<tr>
			  			<td>0x20000134</td>
			  			<td><a href="#ULMII.IpgTmrFs-0x20000134">IpgTmrFs</a></td>
			  			<td>RW</td>
			  			<td>30550A0E</td>
						<tr>
			  			<td>0x20000138</td>
			  			<td><a href="#ULMII.IpgTmrHs-0x20000138">IpgTmrHs</a></td>
			  			<td>RW</td>
			  			<td>00670C01</td>
						<tr>
			  			<td>0x2000013C</td>
			  			<td><a href="#ULMII.PhyPipeLineDelays-0x2000013C">PhyPipeLineDelays</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						<tr>
			  			<td>0x20000140</td>
			  			<td><a href="#ULMII.IpgTmrSof2Dat-0x20000140">IpgTmrSof2Dat</a></td>
			  			<td>RW</td>
			  			<td>003f0A0C</td>
						</tr>


	</tbody>
	</table>

	<h3>Register Descriptions</h3>
	<!--
		**********************************************************************
	 	Description of the Id Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.Id-0x20000100">Id</a></h3>
	<p class="text">Offset: 0x20000100</p>
	<p class="text"></p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31:0</td>
		  				<td><p>Id[31:0]</p></td>
		  				<td>
								<p>Chip ID set to ASCII "ULM2"</p>

							</td>
		  				<td>R</td>
		  				<td>ULM2</td>
		  				<td>ascii</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the Rev Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.Rev-0x20000104">Rev</a></h3>
	<p class="text">Offset: 0x20000104</p>
	<p class="text">This register contains 4 types of revision information.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:16</td>
		  				<td class="nameCol">RESERVED_BITS31_16</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>15:8</td>
		  				<td><p>CvsMajor[7:0]</p></td>
		  				<td>
								<p></p>

							</td>
		  				<td>R</td>
		  				<td>1</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>7:0</td>
		  				<td><p>CvsMinor[7:0]</p></td>
		  				<td>
								<p></p>

							</td>
		  				<td>R</td>
		  				<td>13</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the CnfgSts Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.CnfgSts-0x20000108">CnfgSts</a></h3>
	<p class="text">Offset: 0x20000108</p>
	<p class="text">This register is used to control behavior and read statistics associated with reset.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>Irq</p></td>
		  				<td>
								<p>Indicates that there is an unserviced interrupt in the ULM component.  Use the InterruptSrc to determine the source of interrupt and clear it.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">30:18</td>
		  				<td class="nameCol">RESERVED_BITS30_18</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>17</td>
		  				<td><p>Eco1IgnorePreTimeout</p></td>
		  				<td>
								<p>Ignore hub_setup_timeout in ulmii_rxs.<br><br>
                NOTE: Write Only for GE ASIC</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>16</td>
		  				<td><p>Eco1PreTimeoutClearFix</p></td>
		  				<td>
								<p>Clear hub_setup_timeout in ulmii_rxs when in WAIT_SYNC state.<br><br>
                NOTE: Write Only for GE ASIC</p>

							</td>
		  				<td>RW</td>
		  				<td>1</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">15:14</td>
		  				<td class="nameCol">RESERVED_BITS15_14</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>13:12</td>
		  				<td><p>SpdDet[1:0]</p></td>
		  				<td>
								<p>This register holds the speed that was negotiated to during hardware controlled operations.  Only valid when NegDone status is = 1.<br/><br/>00 = HS<br/>01 = FS<br/>10 = LS<br/>11 = No speed negotiated</p>

							</td>
		  				<td>R</td>
		  				<td>11</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>DrvExtVbus</p></td>
		  				<td>
								<p>In UTMI mode this signal changes the state of a top level output register which can be used to enable or disable an external Vbus power switch.  In ULPI mode this pin still functions but also allows the ULPI register update to enable the Vbus as per ULPI specification.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10</td>
		  				<td><p>LowPwrEn</p></td>
		  				<td>
								<p>This bit allows the ULM to drive the UTMI SUSPEND pin which will disable the PHY's internal PLL's.  This must only be used in systems where the internal PHY PLLs will not affect operation of the SOC.<br/><br/>0 - Low power mode not supported<br/>1 - Low power mode supported</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>9:8</td>
		  				<td><p>PhySelSts[1:0]</p></td>
		  				<td>
								<p>This register is read by software to configure the appropriate PHY settings (ULPI/UTMI, Asynchronous XCVR support etc).  Software will read this register and write the value into the PhyMode register.  Encoding is as follows:<br/><br/>00 - UTMI parallel support only<br/>01 - UTMI parallel and asynchronous support<br/>10 - ULPI parallel support only<br/>11 - ULPI parallel and asynchronous support</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>HwSwSel</p></td>
		  				<td>
								<p>Allows Software to override all automatic functions of the UED and manage the events on the USB directly. <br/><br/>0 = Software will use the UtmiPhyCtrlSts register to manage the port.<br/>1 = Port management is done by the hardware.</p>

							</td>
		  				<td>RW</td>
		  				<td>1</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>AsyncXcvrTxActState</p></td>
		  				<td>
								<p>Sets the asynchronous transceivers active transmitter enable state.  Some USB PHY's require active low, others require active high.  The operational setting of this bit needs to be determined and configured before any USB action can be started.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">5</td>
		  				<td class="nameCol">RESERVED_BIT5</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>RsmMinEn</p></td>
		  				<td>
								<p>Valid in DFP mode only.  If this bit is set it will force the DFP to generate resume timing for a minimum of 20ms (as defined by USB specification).  If it is cleared then the resume sequence is ended by disabling the ExtRsm bit in the Ctrl register.  If this is the case it is important to realize that the ExtRsm bit must be set at the same time or prior to setting the GenRsm bit.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3:2</td>
		  				<td><p>SpdSel[1:0]</p></td>
		  				<td>
								<p>This register sets the speed to negotiate to.<br/><br/>00 = HS, Try to negotiate to a maximum speed of HS<br/>01 = FS, Only negotiate to a maximum speed of FS<br/>10 = LS, Only allow LS operation<br/>11 = Automatically negotiate to the highest USB speed allowed.</p>

							</td>
		  				<td>RW</td>
		  				<td>11</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>ConDis</p></td>
		  				<td>
								<p>This register is used in both DFP and UFP modes.<br/><br/>1 = Connect<br/>0 = Disconnect</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>DfpUfp</p></td>
		  				<td>
								<p>Enables the ULM to behave in host or device (peripheral) mode.<br/><br/>0 = Upstream Facing Port<br/>1 = Downstream Facing Port</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the Ctrl Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.Ctrl-0x2000010C">Ctrl</a></h3>
	<p class="text">Offset: 0x2000010C</p>
	<p class="text">This register is used to separate controls from the status and configuration registers.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:11</td>
		  				<td class="nameCol">RESERVED_BITS31_11</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>10</td>
		  				<td><p>GenK</p></td>
		  				<td>
								<p>Valid in both peripheral and host mode.  Generates a Chirp K on the bus.  Software is responsible for turning this bit off when it is done using this function.  ULM should be idle or the DisableUed bit set to 1 when this is being used.<br/><br/>Active high.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>GenJ</p></td>
		  				<td>
								<p>Valid in both peripheral and host mode.  Generates a Chirp J on the bus.  Software is responsible for disabling this bit when it has finished using its function.  ULM should be idle or the DisableUed bit set to 1 when this is being used.<br/><br/>Active high.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>GenSe0</p></td>
		  				<td>
								<p>Valid only in host mode.  Allows software to generate an SE0 event on the bus.  Software is responsible for disabling this bit.<br/><br/>Active high signal.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">7:6</td>
		  				<td class="nameCol">RESERVED_BITS7_6</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>5</td>
		  				<td><p>GenRmtWkp</p></td>
		  				<td>
								<p>Valid only in peripheral mode.  When acting as a device generates the peripheral remote wakeup signaling on the bus.  This bit is self clearing as soon as the event is serviced.<br/><br/>Active high.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>GenSusp</p></td>
		  				<td>
								<p>Valid in DFP mode only.  If a packet is already being transmitted it will wait until the packet is complete then gate any further core transmissions.  If the port was in high speed operation then it will immediately revert to full speed mode.  If it was operating in full speed or low speed mode it will do nothing.  Upon completion of gating the core transmission and the return to IDLE state it will start the 3ms which when expires will indicate the bus has entered the suspended state.  Upon accepting the command the ULM will clear this bit field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>ExtRsm</p></td>
		  				<td>
								<p>This register is used only in the REX mode.  When this bit is set to 1 the REX UED extends the resume signaling indefinitely on the REX port.  If this bit is clear the resume signaling will end after the Tdrsmdn timer expires.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>GenRsm</p></td>
		  				<td>
								<p>Valid only in host mode.  When acting as a host, generates the host resume conditioning on the bus.  This bit is self clearing as soon as the event is serviced.<br/><br/>Active high.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>ExtRst</p></td>
		  				<td>
								<p>Keeps the Reset sequence until either the Tdrst_max and Tdrst min timers expire</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>GenRst</p></td>
		  				<td>
								<p>Valid in host mode only.  When acting as a host, forces the host reset conditions onto the bus.  No meaning as a peripheral.  This bit is self clearing as soon as the event is serviced.<br/><br/>Active high.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntSrc Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.IntSrc-0x20000110">IntSrc</a></h3>
	<p class="text">Offset: 0x20000110</p>
	<p class="text">Interrupt Status Registers</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:14</td>
		  				<td class="nameCol">RESERVED_BITS31_14</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>13</td>
		  				<td><p>LngPktErr</p></td>
		  				<td>
								<p>This bit is valid in both the DFP and UFP modes.  If the ULMII detects a babbling packet error (a packet that exceeds the maximum length of a packet for the speed of ULMII operation) during reception the ULMII will pulse this signal for one clock cycle.  Because this signal is valid only for one clock cycle software will not necessarily be able to use this for anything useful.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>12</td>
		  				<td><p>BitStuffErr</p></td>
		  				<td>
								<p>This bit is valid in both the DFP and UFP modes.  If the ULMII detects a bitstuff error during reception it will pulse this for one clock cycle.  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">11:10</td>
		  				<td class="nameCol">RESERVED_BITS11_10</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>Discon</p></td>
		  				<td>
								<p>This bit is valid in both the DFP and UFP modes.  If the CnfgSts.ConDis bit goes from set to clear or while the the CnfgSts.ConDis is set and the ULMII is removed from a downstream facing port (UFP mode) or a upstream facing port is removed from the ULMII (DFP mode) this bit will pulse for one clock cycle.  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>Conn</p></td>
		  				<td>
								<p>This bit is valid in both the DFP and UFP modes.  If the CnfgSts.ConDis bit is set this allows the ULMII to detect a valid connect/disconnect condition.  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>RsmDone</p></td>
		  				<td>
								<p>This bit is valid in both DFP and UFP modes.  This bit indicates that the ULMII has detected (UFP) or generated (DFP) the end of the resume sequence (either an upstream port resume initiated resume, remote wakeup or a ULMII controlled resume).  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>RmtWkp</p></td>
		  				<td>
								<p>This bit is valid in DFP mode only.  This bit indicates the ULMII, while in the USB suspended state, has detected USB resume signaling from a device connected downstream.  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5</td>
		  				<td><p>HstRsmDet</p></td>
		  				<td>
								<p>This bit is used in conjunction with the enable bit to set the sticky flag bit in the IntFlag.HstRsmDet register.  This bit indicates the ULMII, while in the USB suspended state, has detected USB resume signaling from the host.  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>SusDet</p></td>
		  				<td>
								<p>This bit is valid in both UFP and DFP modes.  This bit is used in conjunction with the enable bit to set the sticky flag bit in the IntFlag.SusDet register.  This bit indicates the ULMII has detected there has been no transitions from the USB idle state for a period of 3ms for FS/LS and 3.125ms for HS.  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">3</td>
		  				<td class="nameCol">RESERVED_BIT3</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>BusRstDone</p></td>
		  				<td>
								<p>This bit is valid in both UFP and DFP modes.  This bit is used in conjunction with the enable bit to set the sticky flag bit in the IntFlag.BusRstDone register.  This bit indicates that the internal hardware of the ULMII has determined the USB reset has completed.  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>NegDone</p></td>
		  				<td>
								<p>This bit is valid in both UFP and DFP modes.  This bit is used in conjunction with the enable bit to set the sticky flag bit in the IntFlag.NegDone register.  This bit indicates that the internal hardware of the ULMII has determined the final operating speed of the USB.  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>BusRstDet</p></td>
		  				<td>
								<p>This bit indicates that the internal hardware of the ULMII detected the start of the USB reset signaling.  Since this signal is valid only for one clock cycle software should not rely on being able to use this bit reliably.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntEn Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.IntEn-0x20000114">IntEn</a></h3>
	<p class="text">Offset: 0x20000114</p>
	<p class="text">Mask Register for ULM interrupt events</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:14</td>
		  				<td class="nameCol">RESERVED_BITS31_14</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>13</td>
		  				<td><p>LngPktErr</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc. LngPktErr is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>12</td>
		  				<td><p>BitStuffErr</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.BitStuffErr is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">11:10</td>
		  				<td class="nameCol">RESERVED_BITS11_10</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>Discon</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.DisCon is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>Conn</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.Conn is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>RsmDone</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.RsmDone is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>RmtWkp</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.RmtWkp is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5</td>
		  				<td><p>HstRsmDet</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.HstRsmDet is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>SusDet</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.SusDet is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">3</td>
		  				<td class="nameCol">RESERVED_BIT3</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>BusRstDone</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.BusRstDone is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>NegDone</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.NegDone is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>BusRstDet</p></td>
		  				<td>
								<p>Setting this bit to 1 allows an interrupt to be generated when IntSrc.BusRstDet is set by the ULMII.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntFlag Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.IntFlag-0x20000118">IntFlag</a></h3>
	<p class="text">Offset: 0x20000118</p>
	<p class="text"></p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:14</td>
		  				<td class="nameCol">RESERVED_BITS31_14</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>13</td>
		  				<td><p>LngPktErr</p></td>
		  				<td>
								<p>This bit is valid in both the DFP and UFP modes.  If the ULMII detects a babbling packet error (a packet that exceeds the maximum length of a packet for the speed of ULMII operation) during reception and IntEn.LngPktErr and IntSrc.LngPktErr are set then this bit will be set and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>12</td>
		  				<td><p>BitStuffErr</p></td>
		  				<td>
								<p>This bit is valid in both the DFP and UFP modes.  If the ULMII detects a bitstuff error during reception and IntEn.BitStuffErr and IntSrc.BitStuffErr are set then this bit will be set and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">11:10</td>
		  				<td class="nameCol">RESERVED_BITS11_10</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>Discon</p></td>
		  				<td>
								<p>This bit is valid in both the DFP and UFP modes.  If the CnfgSts.ConDis bit goes from set to clear or while the the CnfgSts.ConDis is set and the ULMII is removed from a downstream facing port (UFP mode) or a upstream facing port is removed from the ULMII (DFP mode) and the IntEn.DisCon and IntSrc.DisCon bits are set this will trigger an interrupt and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>Conn</p></td>
		  				<td>
								<p>This bit is valid in both the DFP and UFP modes.  If the CnfgSts.ConDis bit is set and the IntEn.Conn and IntSrc.Conn bit are set this will trigger an interrupt and remain set until software clears it when a upstream facing port or a downstream facing port is connected to the ULMII.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>RsmDone</p></td>
		  				<td>
								<p>This bit is valid in both DFP and UFP modes.  This bit indicates that the ULMII has detected (UFP) or generated (DFP) the end of the resume sequence (either an upstream port resume initiated resume, remote wakeup or a ULMII controlled resume).  When IntEn.RsmDone and the IntSrc.RsmDone are set this bit will trigger an interrupt and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>RmtWkp</p></td>
		  				<td>
								<p>This bit is valid in DFP mode only.  This bit indicates the ULMII, while in the USB suspended state, has detected USB resume signaling from a device connected downstream.  When the IntEn.RmtWkp bit and the IntSrc.RmtWkp are set this bit will trigger an interrupt and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5</td>
		  				<td><p>HstRsmDet</p></td>
		  				<td>
								<p>This bit is valid in UFP mode only.  This bit indicates the ULMII, while in the USB suspended state, has detected USB resume signaling from the downstream port connected to it (e.g. host port).  When the IntEn.HstRsmDet bit and the IntSrc.HstRsmDet are set this bit will trigger an interrupt and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>SusDet</p></td>
		  				<td>
								<p>This bit is valid in both UFP and DFP modes.  This bit indicates the ULMII has detected there has been no transitions from the USB idle state for a period of 3ms for FS/LS and 3.125ms for HS.  When the IntEn.SusDet bit and the IntSrc.SusDet are set this bit will trigger an interrupt and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">3</td>
		  				<td class="nameCol">RESERVED_BIT3</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>BusRstDone</p></td>
		  				<td>
								<p>This bit is valid in both UFP and DFP modes.  This bit indicates the ULMII has met all the necessary conditions to determine the bus reset signaling has completed.  When the IntEn.BusRstDone bit and the IntSrc.BusRstDone are set this bit will trigger an interrupt and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>NegDone</p></td>
		  				<td>
								<p>This bit is valid in both UFP and DFP modes.  This bit indicates the ULMII has met all the necessary conditions to determine the final speed of the USB operation.  When the IntEn.NegDone bit and the IntSrc.NegDone are set this bit will trigger an interrupt and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>BusRstDet</p></td>
		  				<td>
								<p>This bit is only valid when operating in UFP mode.  This bit indicates that the ULMII detected valid bus reset signaling.  When the IntEn.BusRstDet bit and the IntSrc.BusRstDet are set this bit will trigger an interrupt and remain set until software clears it.  Write 1 to clear.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the PhySts Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.PhySts-0x20000120">PhySts</a></h3>
	<p class="text">Offset: 0x20000120</p>
	<p class="text">This register includes all information the PHY is able to present to the ULMII core.  This information is also information extracted from the ULPI RXCMD byte when operating in ULPI mode.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:9</td>
		  				<td class="nameCol">RESERVED_BITS31_9</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>Id</p></td>
		  				<td>
								<p></p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>SessBvalid</p></td>
		  				<td>
								<p></p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>SessAvalid</p></td>
		  				<td>
								<p></p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5</td>
		  				<td><p>SessEnd</p></td>
		  				<td>
								<p>OTG</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>VbusValid</p></td>
		  				<td>
								<p></p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3:2</td>
		  				<td><p>LineState[1:0]</p></td>
		  				<td>
								<p>Unfiltered USB line state (after UTMI phy)</p>

							</td>
		  				<td>R</td>
		  				<td>00</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>HostDisconnect</p></td>
		  				<td>
								<p>When the PHY Dppulldown and Dmpulldown are enabled this signal indicates the device has been removed.  When XCVR mode is set for HS (00b) this signal will only register a disconnect when a SOF is being sent.  Once it indicates a disconnect while in HS it is not valid for a minimum of 4ms.<br/><br/>1 = Device Disconnected<br/>0 = Device Connected</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>Vbus</p></td>
		  				<td>
								<p>If a voltage divided Vbus is connected this bit indicates that.  Governed by the switching thresholds of the input pin.  This pin is to be used by software to detect connection to a host when in UFP mode.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the UlpiAccess Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.UlpiAccess-0x20000128">UlpiAccess</a></h3>
	<p class="text">Offset: 0x20000128</p>
	<p class="text">All PHY controls are abstracted into ULPI control access regardless of PHY type (ULPI or UTMI).  The register mapping for both are described in the ULPI register specifications.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31:24</td>
		  				<td><p>Rdata[7:0]</p></td>
		  				<td>
								<p>When the UlpiAccess.Go bit is cleared at the end of a read transaction this bit field contains that registers value.</p>

							</td>
		  				<td>R</td>
		  				<td>00</td>
		  				<td>hexadecimal</td>
					</tr>
        		<tr>
        	  	<td>23:16</td>
		  				<td><p>Wdata[7:0]</p></td>
		  				<td>
								<p>This is the data byte to be written to the ULPI register.</p>

							</td>
		  				<td>RW</td>
		  				<td>00</td>
		  				<td>hexadecimal</td>
					</tr>
        		<tr>
        	  	<td>15:8</td>
		  				<td><p>Addr[7:0]</p></td>
		  				<td>
								<p>ULPI internal register address.</p>

							</td>
		  				<td>RW</td>
		  				<td>00</td>
		  				<td>hexadecimal</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">7:3</td>
		  				<td class="nameCol">RESERVED_BITS7_3</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>Err</p></td>
		  				<td>
								<p>When software is polling on the GO bit and has determined it to have cleared (indicating the end of the action) this bit is valid.  It is only valid at the falling edge of the GO bit.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>WrRdn</p></td>
		  				<td>
								<p>0 = Read Operation<br/>1 = Write Operation</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>Go</p></td>
		  				<td>
								<p>Software will set this bit when a ULPI access is required.  Once this bit is cleared it can use the Rdata or assume the Wdata was written.  This depends on the access mode for the operation being performed.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>

	</table>

	<!--
		**********************************************************************
	 	Description of the Phydbg Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.PhyDbg0-0x2000012C">PhyDbg0</a></h3>
	<p class="text">Offset: 0x2000012C</p>
	<p class="text"></p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31:0</td>
		  				<td><p>dbg[31:0]</p></td>
		  				<td>
								<p> This register manages the non-utmi specific interface to the USB PHY.  Please refer to ASIC documentation.</p>

							</td>
		  				<td>RW</td>
		  				<td>0x00000104</td>
		  				<td>hex</td>
					</tr>

			</tbody>
	</table>


	<!--
		**********************************************************************
	 	Description of the IpgTmrLs Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.IpgTmrLs-0x20000130">IpgTmrLs</a></h3>
	<p class="text">Offset: 0x20000130</p>
	<p class="text"></p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>


        		<tr>
        	  	<td>31:28</td>
		  				<td><p>linestatefilter[3:0]</p></td>
		  				<td>
							        <p> This bit is used to tune the linestate filter for low speed operation.  Note this is a 5 bit counter in which the lowest bit is always 1.<br/>
								  e.g. if 4'bwxyz is written, then the filter will count out 5'bwxyz1, i.e. odd counts only.<br/></p>


							</td>
		  				<td>RW</td>
		  				<td>0x9</td>
		  				<td>hex</td>
					</tr>
        	  	<td>27:16</td>
		  				<td><p>rxtimeout[11:0]</p></td>
		  				<td>
							        <p> This governs the time in xusb clocks that the ULM declares a RX time after TX or RX<br/>
								  UFP LS Serial	  = 0x2BF<br/>
								  UFP LS Parallel = 0x2BF<br/>
								  DFP LS Serial	  = 0x2E7<br/>
								  DFP LS Parallel = 0x2E7<br/></p>


							</td>
		  				<td>RW</td>
		  				<td>0x2BF</td>
		  				<td>hex</td>
					</tr>
        	  	<td>15:8</td>
		  				<td><p>tx2tx[7:0]</p></td>
		  				<td>
						                <p> This governs the time in xusb clocks that the ULM gates TX after TX<br/>
								  LS Serial   = 0x3F<br/>
								  LS Parallel = 0x3F<br/></p>

							</td>
		  				<td>RW</td>
		  				<td>0x3F</td>
		  				<td>hex</td>
					</tr>
        	  	<td>7:0</td>
		  				<td><p>rx2tx[7:0]</p></td>
		  				<td>
								<p> This governs the time in xusb clocks that the ULM gates TX after RX<br/>
								  LS Serial   = 0x3F<br/>
								  LS Parallel = 0x3F<br/></p>

							</td>
		  				<td>RW</td>
		  				<td>0x3F</td>
		  				<td>hex</td>
					</tr>
        		<tr>
        		<tr>

			</tbody>
	</table>

			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>


	<!--
		**********************************************************************
	 	Description of the IpgTmrFs Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.IpgTmrFs-0x20000134">IpgTmrFs</a></h3>
	<p class="text">Offset: 0x20000134</p>
	<p class="text"></p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>


        		<tr>
        	  	<td>31:28</td>
		  				<td><p>linestatefilter[3:0]</p></td>
		  				<td>
							        <p> This bit is used to tune the linestate filter for full speed operation.  Note this is a 5 bit counter in which the lowest bit is always 1.<br/>
								  e.g. if 4'bwxyz is written, then the filter will count out 5'0wxyz.<br/></p>


							</td>
		  				<td>RW</td>
		  				<td>0x3</td>
		  				<td>hex</td>
					</tr>

        	  	<td>27:16</td>
		  				<td><p>rxtimeout[11:0]</p></td>
		  				<td>
							        <p> This governs the time in xusb clocks that the ULM declares a RX time after TX or RX<br/>
								  UFP FS Serial	  = 0x055<br/>
								  UFP FS Parallel = 0x055<br/>
								  DFP FS Serial	  = 0x05A<br/>
								  DFP FS Parallel = 0x05A<br/></p>


							</td>
		  				<td>RW</td>
		  				<td>0x055</td>
		  				<td>hex</td>
					</tr>
        	  	<td>15:8</td>
		  				<td><p>tx2tx[7:0]</p></td>
		  				<td>
						                <p> This governs the time in xusb clocks that the ULM gates TX after TX<br/>
								  FS Serial   = 0x0A<br/>
								  FS Parallel = 0x01<br/></p>

							</td>
		  				<td>RW</td>
		  				<td>0x0A</td>
		  				<td>hex</td>
					</tr>
        	  	<td>7:0</td>
		  				<td><p>rx2tx[7:0]</p></td>
		  				<td>
								<p> This governs the time in xusb clocks that the ULM gates TX after RX<br/>
								  FS Serial   = 0x0E<br/>
								  FS Parallel = 0x04<br/></p>

							</td>
		  				<td>RW</td>
		  				<td>0x0E</td>
		  				<td>hex</td>
					</tr>
        		<tr>
        		<tr>

			</tbody>
	</table>

			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>


	<!--
		**********************************************************************
	 	Description of the IpgTmrHs Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.IpgTmrHs-0x20000138">IpgTmrHs</a></h3>
	<p class="text">Offset: 0x20000138</p>
	<p class="text"></p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>


        	  	<td class="bitsCol">31:28</td>
		  				<td class="nameCol">RESERVED_BITS31_28</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>27:16</td>
		  				<td><p>rxtimeout[11:0]</p></td>
		  				<td>
							        <p> This governs the time in xusb clocks that the ULM declares a RX time after TX or RX<br/>
								  HS              = 0x067<br/></p>


							</td>
		  				<td>RW</td>
		  				<td>0x067</td>
		  				<td>hex</td>
					</tr>
        	  	<td>15:8</td>
		  				<td><p>tx2tx[7:0]</p></td>
		  				<td>
						                <p> This governs the time in xusb clocks that the ULM gates TX after TX<br/>
								  HS          = 0x0C<br/></p>

							</td>
		  				<td>RW</td>
		  				<td>0x0C</td>
		  				<td>hex</td>
					</tr>
        	  	<td>7:0</td>
		  				<td><p>rx2tx[7:0]</p></td>
		  				<td>
								<p> This governs the time in xusb clocks that the ULM gates TX after RX<br/>
								  HS          = 0x01<br/></p>

							</td>
		  				<td>RW</td>
		  				<td>0x01</td>
		  				<td>hex</td>
					</tr>
        		<tr>
        		<tr>

			</tbody>
	</table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>

	<!--
		**********************************************************************
	 	Description of the IpgTmrHs Register and it's BitFields
		**********************************************************************
	-->


	<h3><a name="ULMII.PhyPipeLineDelays-0x2000013C"></a>PhyPipeLineDelays</h3>
	<p class="text">Offset: 0x2000013C</p>
	<p class="text"></p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>

        		<tr>        	  	<td>31:24</td>
		  				<td><p>RxCmdDly[7:0]</p></td>
		  				<td>
							        <p> The maximum delay time it takes to update the linestate after TX EOP <br/>
								  UTMI              = 0x00<br/>
								  ULPI              = 0x00<br/></p>
							</td>
		  				<td>RW</td>
		  				<td>0x00</td>
		  				<td>hex</td>
					</tr>

        	  	<td>23:16</td>
		  				<td><p>TxDatEopDly[7:0]</p></td>
		  				<td>
						                <p> The Maximum time to wait until the DATA EOP is gaurenteed to be on the bus after TXVAL is sampled LO by the PHY<br/>
								  UTMI          = 0x00<br/<br/>
								  ULPI          = 0x00<br/></p>
							</td>
		  				<td>RW</td>
		  				<td>0x00</td>
		  				<td>hex</td>
					</tr>


        	  	<td>15:8</td>
		  				<td><p>TxSofEopDly[7:0]</p></td>
		  				<td>
						                <p> The Maximum time to wait until the SOF EOP is gaurenteed to be on the bus after TXVAL is sampled LO by the PHY<br/>
								  UTMI          = 0x00<br/<br/>
								  ULPI          = 0x00<br/></p>
							</td>
		  				<td>RW</td>
		  				<td>0x00</td>
		  				<td>hex</td>
					</tr>
        	  	<td>7:0</td>
		  				<td><p>TxSopDly[7:0]</p></td>
		  				<td>
								<p> Indicates the maximum time to wait until the SOP is guarenteed to be on the USB after TXVAL is sampled HI the PHY<br/>
								  UTMI          = 0x00<br/<br/>
								  ULPI          = 0x00<br/></p>

							</td>
		  				<td>RW</td>
		  				<td>0x00</td>
		  				<td>hex</td>
					</tr>
        		<tr>
        		<tr>

			</tbody>


	</table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>

	<!--
		**********************************************************************
	 	Description of the IpgTmrSofTx2Tx Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="ULMII.IpgTmrSof2Dat-0x20000140"></a>IpgTmrSof2Dat</h3>
	<p class="text">Offset: 0x20000140</p>
	<p class="text"></p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>


        	  	<td class="bitsCol">31:24</td>
		  				<td class="nameCol">RESERVED_BITS31_28</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>23:16</td>
		  				<td><p>ls[7:0]</p></td>
		  				<td>
							        <p> This adjusts the LS Keep Alive to data TX2TX time for LS</p>


							</td>
		  				<td>RW</td>
		  				<td>0x3F</td>
		  				<td>hex</td>
					</tr>
        	  	<td>15:8</td>
		  				<td><p>fs[7:0]</p></td>
		  				<td>
						                <p> This adjusts the SOF to data TX2TX time for FS</p>

							</td>
		  				<td>RW</td>
		  				<td>0x0A</td>
		  				<td>hex</td>
					</tr>
        	  	<td>7:0</td>
		  				<td><p>hs[7:0]</p></td>
		  				<td>
								<p> This adjusts the SOF to data TX2TX time for HS</p>

							</td>
		  				<td>RW</td>
		  				<td>0x0C</td>
		  				<td>hex</td>
					</tr>
        		<tr>
        		<tr>

			</tbody>
	</table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>



	<table class="footer">
	<tr>
		<td><p>ULMII Memory Mapped Registers</p></td>
		<td><p align="center">&copy;2009 Productivity Design Tools Inc. (PDTi)</p></td>
		<td><p align="right">Generated using <a href="http://www.productive-eda.com">PDTi</a> SpectaReg.</p></td>
	</tr>


	</body>
</html>
