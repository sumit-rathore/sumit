<!--
**********************************************************
 Generated by SpectaReg from PDTi (www.productive-eda.com)
 SpectaReg Revision: 579
 Generated from ViewFileTemplate at: comp_mmreg.html.gen
 ViewFileTemplate Revision: 1057
 Generation date: Wed Jun 27 23:41:22 GMT 2012
**********************************************************
-->

<!--
**************************************************************************
Confidential & Proprietary Property of Productivity Design Tools Inc. (PDTi).
Copyright (c) Productivity Design Tools Inc. (PDTi) 2006, 2007, 2008. All rights reserved.
**************************************************************************
**************************************************************************
*********** THIS FILE GENERATED BY SPECTAGEN - DO NOT EDIT ***************
**************************************************************************
**************************************************************************
**************************************************************************
-->


<html>
<!--
     ***********************************************************************
     Component: Clm
     ***********************************************************************
-->
	<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Clm Component's Memory Mapped Registers</title>
		<link rel="stylesheet" type="text/css" href="comp_mmreg.css">
	</head>
	<body>
	<h2>Clm Component's Memory Mapped Registers</h2>
	<h3><a name="Register_Summary">Register Summary</a></h3>
	<table class="registerSummary">
		<thead>
		<tr>
			<th>Offset</th>
			<th>Register Name</th>
			<th>R/W</th>
			<th>Reset Value (hex)</th>
		</tr>
		</thead>
		<tbody>
						<tr class="abRow">
			  			<td colspan="4">Clm</td>
						</tr>
						<tr>
			  			<td>0x20000200</td>
			  			<td><a href="#Clm.Id-0x20000200">Id</a></td>
			  			<td>R</td>
			  			<td>5F434C4D</td>
						</tr>
						<tr>
			  			<td>0x20000204</td>
			  			<td><a href="#Clm.Rev-0x20000204">Rev</a></td>
			  			<td>R</td>
			  			<td>00000123</td>
						</tr>
						<tr>
			  			<td>0x20000208</td>
			  			<td><a href="#Clm.IntEn-0x20000208">IntEn</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x2000020C</td>
			  			<td><a href="#Clm.IntSrc-0x2000020C">IntSrc</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000210</td>
			  			<td><a href="#Clm.IntFlg-0x20000210">IntFlg</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000214</td>
			  			<td><a href="#Clm.MlpConfig0-0x20000214">MlpConfig0</a></td>
			  			<td>RW</td>
			  			<td>00000004</td>
						</tr>
						<tr>
			  			<td>0x20000218</td>
			  			<td><a href="#Clm.MlpConfig1-0x20000218">MlpConfig1</a></td>
			  			<td>RW</td>
			  			<td>20130393</td>
						</tr>
						<tr>
			  			<td>0x2000021C</td>
			  			<td><a href="#Clm.PhyConfig-0x2000021C">PhyConfig</a></td>
			  			<td>RW</td>
			  			<td>0110004A</td>
						</tr>
						<tr>
			  			<td>0x20000220</td>
			  			<td><a href="#Clm.EtherType-0x20000220">EtherType</a></td>
			  			<td>RW</td>
			  			<td>0000FFFF</td>
						</tr>

						<tr>
			  			<td>0x20000224</td>
			  			<td><a href="#Clm.MacSrcLsw-0x20000224">MacSrcLsw</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						<tr>

			  			<td>0x20000228</td>
			  			<td><a href="#Clm.MacSrcMsw-0x20000228">MacSrcMsw</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>

						<tr>
			  			<td>0x2000022C</td>
			  			<td><a href="#Clm.MacDst-0x2000022C">MacDstLsw</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>

						<tr>
			  			<td>0x20000230</td>
			  			<td><a href="#Clm.MacDstMsw-0x20000230">MacDstMsw</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						<tr>
			  			<td>0x20000234</td>
			  			<td><a href="#Clm.MacRdDst-0x20000234">MacRdDstLsw</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000238</td>
			  			<td><a href="#Clm.MacRdDstMsw-0x20000238">MacRdDstMsw</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						<tr>
			  			<td>0x2000023C</td>
			  			<td><a href="#Clm.TxStats-0x2000023C">TxStats</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000240</td>
			  			<td><a href="#Clm.RxStats-0x20000240">RxStats</a></td>
			  			<td>RW</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000244</td>
			  			<td><a href="#Clm.TxStatsETR-0x20000244">TxStatsETR</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000248</td>
			  			<td><a href="#Clm.RxStatsETR-0x20000248">RxStatsETR</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x2000024C</td>
			  			<td><a href="#Clm.MlpStatus-0x2000024C">MlpStatus</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000250</td>
			  			<td><a href="#Clm.MlpIcsStatus-0x20000250">MlpIcsStatus</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>
						<tr>
			  			<td>0x20000254</td>
			  			<td><a href="#Clm.MlpVpHold-0x20000254">MlpVpHold</a></td>
			  			<td>R</td>
			  			<td>00000000</td>
						</tr>


	</tbody>
	</table>

	<h3>Register Descriptions</h3>
	<!--
		**********************************************************************
	 	Description of the Id Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.Id-0x20000200">Id</a></h3>
	<p class="text">Offset: 0x20000200</p>
	<p class="text">CLM registers ASCII identification register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31:0</td>
		  				<td><p>Id[31:0]</p></td>
		  				<td>
								<p>CLM registers ASCII identification field.</p>

							</td>
		  				<td>R</td>
		  				<td>_CLM</td>
		  				<td>ascii</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the Rev Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.Rev-0x20000204">Rev</a></h3>
	<p class="text">Offset: 0x20000204</p>
	<p class="text">CLM registers CVS revision register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>Irq</p></td>
		  				<td>
								<p></p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">30:16</td>
		  				<td class="nameCol">RESERVED_BITS30_16</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>15:8</td>
		  				<td><p>CvsMajor[7:0]</p></td>
		  				<td>
								<p>CLM registers CVS major revision field.  This field relates to the pre-decimal CVS version number, as seen in the format: MAJOR.MINOR</p>

							</td>
		  				<td>R</td>
		  				<td>1</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>7:0</td>
		  				<td><p>CvsMinor[7:0]</p></td>
		  				<td>
								<p>CLM registers CVS minor revision field.  This field relates to the post-decimal CVS version number, as seen in the format: MAJOR.MINOR</p>

							</td>
		  				<td>R</td>
		  				<td>36</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntEn Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.IntEn-0x20000208">IntEn</a></h3>
	<p class="text">Offset: 0x20000208</p>
	<p class="text">Interrupt mask register.<br/><br/>0 = interrupt disabled.<br/>1 = interrupt enabled.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>MlpRxSfifoOflow</p></td>
		  				<td>
								<p>MLP RX sfifo overflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>30</td>
		  				<td><p>MlpRxAfifoOflow</p></td>
		  				<td>
								<p>MLP RX afifo overflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>29</td>
		  				<td><p>MlpRxSeqErr</p></td>
		  				<td>
								<p>MLP RX sequence error interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>28</td>
		  				<td><p>MlpRxPldErr</p></td>
		  				<td>
								<p>MLP RX payload crc validation failure interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>27</td>
		  				<td><p>MlpRxHdrErr</p></td>
		  				<td>
								<p>MLP RX header crc validation failure interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>26</td>
		  				<td><p>MlpRxFcDropErr</p></td>
		  				<td>
								<p>MLP RX packet dropped, due to local flow control condition, interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>25</td>
		  				<td><p>MlpTxToCntLvl</p></td>
		  				<td>
								<p>MLP TX highest vport status table timeout counter level achieved interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>24</td>
		  				<td><p>MlpTxW4RErr</p></td>
		  				<td>
								<p>MLP TX link wait for response error interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>23</td>
		  				<td><p>MlpTxRtyErr</p></td>
		  				<td>
								<p>MLP TX link retry failure event interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>22</td>
		  				<td><p>MlpTxRtyWrn</p></td>
		  				<td>
								<p>MLP TX link retry event interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>21</td>
		  				<td><p>MlpTxVp0LenErr</p></td>
		  				<td>
								<p>MLP TX invalid vport0 data packet length interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>20</td>
		  				<td><p>MlpTxVpdropErr</p></td>
		  				<td>
								<p>MLP TX data/datn drop, due to invalid vport, interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>19</td>
		  				<td><p>MlpTxIcsFluQErr</p></td>
		  				<td>
								<p>MLP TX cache flush QID request error interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>18</td>
		  				<td><p>MlpTxIcsRetQErr</p></td>
		  				<td>
								<p>MLP TX cache return QID request error interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>17</td>
		  				<td><p>MlpTxIcsNewQErr</p></td>
		  				<td>
								<p>MLP TX cache new QID request error interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>16</td>
		  				<td><p>MlpTxIcsQidAEmpty</p></td>
		  				<td>
								<p>MLP TX cache Queue ID almost empty interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>15</td>
		  				<td><p>MlpTxIcsQidEmpty</p></td>
		  				<td>
								<p>MLP TX cache Queue ID empty interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>14</td>
		  				<td><p>MlpTxIcsSidAEmpty</p></td>
		  				<td>
								<p>MLP TX cache Segment ID almost empty interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>13</td>
		  				<td><p>MlpTxIcsSidEmpty</p></td>
		  				<td>
								<p>MLP TX cache Segment ID empty interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>12</td>
		  				<td><p>MlpTxIcsUflow</p></td>
		  				<td>
								<p>MLP TX cache underflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>MlpTxIcsOflow</p></td>
		  				<td>
								<p>MLP TX cache overflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10</td>
		  				<td><p>MlpTxIcsInitDone</p></td>
		  				<td>
								<p>MLP TX cache initialization complete interrupt enable field. or
								   CLM Ethernet Packet Drop when Cache is almost full.
								</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>MlpLinkEvent</p></td>
		  				<td>
								<p>MLP link event interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>PhyDfrmErrCrcEnet</p></td>
		  				<td>
								<p>PHY deframer MII level 2 framing CRC error interrupt enable field (ENET frame).</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>PhyDfrmErrCrcUsb</p></td>
		  				<td>
								<p>PHY deframer MII level 2 framing CRC error interrupt enable field (USB frame).</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>PhyDfrmErrTout</p></td>
		  				<td>
								<p>IPF deframer timeout interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5</td>
		  				<td><p>PhyDfrmErrIpf</p></td>
		  				<td>
								<p>IPF deframer error interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>PhyDfrmErrFrm</p></td>
		  				<td>
								<p>PHY deframer framing error interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>RxStats</p></td>
		  				<td>
								<p>RxStats overflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>TxStats</p></td>
		  				<td>
								<p>TxStats overflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>RxStatsETR</p></td>
		  				<td>
								<p>RxStatsETR overflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>TxStatsETR</p></td>
		  				<td>
								<p>TxStatsETR overflow interrupt enable field.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntSrc Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.IntSrc-0x2000020C">IntSrc</a></h3>
	<p class="text">Offset: 0x2000020C</p>
	<p class="text">Interrupt source register.  These fields are pulsed or held '1' when an interrupt situation has occurred or is persisting.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>MlpRxSfifoOflow</p></td>
		  				<td>
								<p>MLP RX sfifo overflow interrupt source field.  This field is pulsed '1' when an overflow of the received buffer has been detected.<br/><br/>MLPR to XCRM sfifo.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>30</td>
		  				<td><p>MlpRxAfifoOflow</p></td>
		  				<td>
								<p>MLP RX afifo overflow interrupt source field.  This field is pulsed '1' when an overflow of the received buffer has been detected.<br/><br/>MLPR to MLPT afifo.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>29</td>
		  				<td><p>MlpRxSeqErr</p></td>
		  				<td>
								<p>MLP RX sequence error interrupt source field.  This field is pulsed '1' when a sequence error has been detected and no pending read of the Mlp.MlpVpHold register is required.<br/><br/>Note: The vport associated with the error is captured in the CLM.MlpVpHold register.<br/>Note: A new interrupt source pulse will not occur until CLM.MlpVpHold is read.<br/>Note: Clear associated interrupt before reading CLM.MlpVpHold to avoid interrupt miss.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>28</td>
		  				<td><p>MlpRxPldErr</p></td>
		  				<td>
								<p>MLP RX payload crc validation failure interrupt source field.  This field is pulsed '1' when a crc failure has been detected in the MLP payload and no pending read of the Mlp.MlpVpHold register is required.<br/><br/>Note: The vport associated with the error is captured in the CLM.MlpVpHold register.<br/>Note: A new interrupt source pulse will not occur until CLM.MlpVpHold is read.<br/>Note: Clear associated interrupt before reading CLM.MlpVpHold to avoid interrupt miss.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>27</td>
		  				<td><p>MlpRxHdrErr</p></td>
		  				<td>
								<p>MLP RX header crc validation failure interrupt source field.  This field is pulsed '1' when a crc failure has been detected in the MLP header.  <br/><br/>Note: Unfortunately the header information cannot be trusted so the vport cannot be extracted and provided.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>26</td>
		  				<td><p>MlpRxFcDropErr</p></td>
		  				<td>
								<p>MLP RX packet dropped, due to local flow control condition, interrupt source field.  This field is pulsed '1' when the MLP RX has dropped a packet due to insufficient space in the reception buffersand no pending read of the Mlp.MlpVpHold register is required.<br/><br/>Note: The vport associated with the error is captured in the CLM.MlpVpHold register.<br/>Note: A new interrupt source pulse will not occur until CLM.MlpVpHold is read.<br/>Note: Clear associated interrupt before reading CLM.MlpVpHold to avoid interrupt miss.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>25</td>
		  				<td><p>MlpTxToCntLvl</p></td>
		  				<td>
								<p>MLP TX highest vport status table timeout counter level achieved interrupt source field.  This field is '1' when a vport status timeout counter level is greater than or equal to the defined CLM.MLPCONFIG1.ToCntThresh level.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>24</td>
		  				<td><p>MlpTxW4RErr</p></td>
		  				<td>
								<p>MLP TX link wait for response error interrupt source field.  This field is pulsed '1' when a wait for response event has occurredand no pending read of the Mlp.MlpVpHold register is required.<br/><br/>Note: a wait for response event is when a retriable packet has not successfully been acknowledged within the register defined threshold time.  This scenario will trigger a retry of pending retriable packets already transmitted to the vport.<br/><br/>Note: this event will not occur if this is the 4th wait for response timeout to the vport.  In that case a retry failure event will super-cede this event.<br/><br/>Note: The vport associated with the error is captured in the CLM.MlpVpHold register.<br/>Note: A new interrupt source pulse will not occur until CLM.MlpVpHold is read.<br/>Note: Clear associated interrupt before reading CLM.MlpVpHold to avoid interrupt miss.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>23</td>
		  				<td><p>MlpTxRtyErr</p></td>
		  				<td>
								<p>MLP TX link retry failure event interrupt source field.  This field is pulsed '1' when a retry failure event has occurred and no pending read of the Mlp.MlpVpHold register is required.<br/><br/>Note: a retry failure event is when any retriable packet is re-transmitted 3 times without a successful acknowledgement.  (4 total transmissions).<br/><br/>Note: a retry failure case will linkdown the associated vport, then attempt to re-initialize with STAT packets.  All existing cached packets destined for the vport will be self-cleaned from the MLP TX cache, and any incoming packet will be dropped until link is re-initialized.<br/><br/>Note: The vport associated with the error is captured in the CLM.MlpVpHold register.<br/>Note: A new interrupt source pulse will not occur until CLM.MlpVpHold is read.<br/>Note: Clear associated interrupt before reading CLM.MlpVpHold to avoid interrupt miss.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>22</td>
		  				<td><p>MlpTxRtyWrn</p></td>
		  				<td>
								<p>MLP TX link retry event interrupt source field.  This field is pulsed '1' when the MLP has begun a retry sequence and no pending read of the Mlp.MlpVpHold register is required.<br/><br/>Note: a retry sequence may contain 1 or more data packets for retry.  This event is not 1:1 with number of packets retried.<br/><br/>Note: The vport associated with the error is captured in the CLM.MlpVpHold register.<br/>Note: A new interrupt source pulse will not occur until CLM.MlpVpHold is read.<br/>Note: Clear associated interrupt before reading CLM.MlpVpHold to avoid interrupt miss.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>21</td>
		  				<td><p>MlpTxVp0LenErr</p></td>
		  				<td>
								<p>MLP TX invalid vport0 data packet length interrupt source field.  This field is pulsed '1' when the MLP TX has detected that an over-sized retriable data packet was destined to vport 0. <br/><br/>Note: max retriable vport 0 data packet is 2 XICS cache words (16 bytes).</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>20</td>
		  				<td><p>MlpTxVpdropErr</p></td>
		  				<td>
								<p>MLP TX data/datn drop, due to invalid vport, interrupt source field.  This field is pulsed '1' when a data or datn packet is dropped by the MLP tx module because it was destined for a vport that is not linkup and no pending read of the Mlp.MlpVpHold register is required.<br/><br/>Note: The vport associated with the error is captured in the CLM.MlpVpHold register.<br/>Note: A new interrupt source pulse will not occur until CLM.MlpVpHold is read.<br/>Note: Clear associated interrupt before reading CLM.MlpVpHold to avoid interrupt miss.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>19</td>
		  				<td><p>MlpTxIcsFluQErr</p></td>
		  				<td>
								<p>MLP TX cache flush QID request error interrupt source field.  This field is pulsed '1' when a flush QID request error has occurred.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>18</td>
		  				<td><p>MlpTxIcsRetQErr</p></td>
		  				<td>
								<p>MLP TX cache return QID request error interrupt source field.  This field is pulsed '1' when a return QID request error has occurred.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>17</td>
		  				<td><p>MlpTxIcsNewQErr</p></td>
		  				<td>
								<p>MLP TX cache new QID request error interrupt source field.  This field is pulsed '1' when a new QID request error has occurred.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>16</td>
		  				<td><p>MlpTxIcsQidAEmpty</p></td>
		  				<td>
								<p>MLP TX cache Queue ID almost empty interrupt source field.  This field is pulsed one when the QID fifo count passes above or below the register defined threshold.  Will need to read MlpIcsStatus.QidAEmpty field to determine status.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>15</td>
		  				<td><p>MlpTxIcsQidEmpty</p></td>
		  				<td>
								<p>MLP TX cache Queue ID empty interrupt source field.  This field is pulsed one when the QID fifo goes empty or goes not empty. Will need to read MlpIcsStatus.QidEmpty field to determine status.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>14</td>
		  				<td><p>MlpTxIcsSidAEmpty</p></td>
		  				<td>
								<p>MLP TX cache Segment ID almost empty interrupt source field.  This field is pulsed one when the SID fifo count passes above or below the register defined threshold.  Will need to read MlpIcsStatus.SidAEmpty field to determine status.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>13</td>
		  				<td><p>MlpTxIcsSidEmpty</p></td>
		  				<td>
								<p>MLP TX cache Segment ID empty interrupt source field.  This field is pulsed one when the SID fifo goes empty or goes not empty. Will need to read MlpIcsStatus.SidEmpty field to determine status.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>12</td>
		  				<td><p>MlpTxIcsUflow</p></td>
		  				<td>
								<p>MLP TX cache underflow interrupt source field.  This field is pulsed '1' in the event that the MLP TX cache has detected and underflow condition.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>MlpTxIcsOflow</p></td>
		  				<td>
								<p>MLP TX cache overflow interrupt source field.  This field is pulsed '1' in the event that the MLP TX cache has detected and overflow condition.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10</td>
		  				<td><p>MlpTxIcsInitDone</p></td>
		  				<td>
								<p>MLP TX cache initialization complete interrupt source field.  This field is pulsed '1' when the initialization is complete.  Should only happen once when MlpConfig0.TxEnable is set.
								or CLM Ethernet Packet Drop when Cache is almost full.
								</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>MlpLinkEvent</p></td>
		  				<td>
								<p>MLP link event interrupt source field.  This field is pulsed '1' on any status change to the linkup condition for any vport.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>PhyDfrmErrCrcEnet</p></td>
		  				<td>
								<p>PHY deframer MII level 2 framing CRC error interrupt source field (ENET frame).  This field is pulsed every time the deframer has detected a reception error in the MII level 2 frame.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>PhyDfrmErrCrcUsb</p></td>
		  				<td>
								<p>PHY deframer MII level 2 framing CRC error interrupt source field (USB frame).  This field is pulsed every time the deframer has detected a reception error in the MII level 2 frame.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>PhyDfrmErrTout</p></td>
		  				<td>
								<p>IPF deframer timeout interrupt source field.  This field is pulsed every time the IPF deframer has detected a timeout condition has occurred in the incoming reception stream.  Associated with the PhyConfig.ParToutThresh register.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5</td>
		  				<td><p>PhyDfrmErrIpf</p></td>
		  				<td>
								<p>IPF deframer error interrupt source field.  This field is pulsed every time the IPF deframer has detected an error in the incoming reception stream.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>PhyDfrmErrFrm</p></td>
		  				<td>
								<p>PHY deframer framing error interrupt source field.  This field is pulsed every time the PHY deframer has determined that a framing error in the reception stream has occurred.  In this case the PHY deframer will flush the remainder of the transmission.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>RxStats</p></td>
		  				<td>
								<p>RxStats overflow interrupt source field.  This field is 1 when any CLM.RxStats.xxxOflow is set.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>TxStats</p></td>
		  				<td>
								<p>TxStats overflow interrupt source field.  This field is 1 when any CLM.TxStats.xxxOflow is set.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>RxStatsETR</p></td>
		  				<td>
								<p>RxStatsETR overflow interrupt source field.  This field is 1 when any CLM.RxStatsETR.xxxOflow is set.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>TxStatsETR</p></td>
		  				<td>
								<p>TxStatsETR overflow interrupt source field.  This field is 1 when any CLM.TxStatsETR.xxxOflow is set.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the IntFlg Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.IntFlg-0x20000210">IntFlg</a></h3>
	<p class="text">Offset: 0x20000210</p>
	<p class="text">Interrupt flag register.  This field is set '1' when the interrupt source field has seen '1' and the interrupt enable field is set '1'. <br/><br/>0 = interrupt not detected.<br/>1 = interrupt detected.<br/><br/>Note: write '1' to clear field.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>MlpRxSfifoOflow</p></td>
		  				<td>
								<p>MLP RX sfifo overflow interrupt flag field.<br/><br/>SEVERITY: FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>30</td>
		  				<td><p>MlpRxAfifoOflow</p></td>
		  				<td>
								<p>MLP RX afifo overflow interrupt flag field.<br/><br/>SEVERITY: FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>29</td>
		  				<td><p>MlpRxSeqErr</p></td>
		  				<td>
								<p>MLP RX sequence error interrupt flag field.<br/><br/>SEVERITY: WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>28</td>
		  				<td><p>MlpRxPldErr</p></td>
		  				<td>
								<p>MLP RX payload crc validation failure interrupt flag field.<br/><br/>DEVERITY: WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>27</td>
		  				<td><p>MlpRxHdrErr</p></td>
		  				<td>
								<p>MLP RX header crc validation failure interrupt flag field.<br/><br/>SEVERITY: WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>26</td>
		  				<td><p>MlpRxFcDropErr</p></td>
		  				<td>
								<p>MLP RX packet dropped, due to local flow control condition, interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL/WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>25</td>
		  				<td><p>MlpTxToCntLvl</p></td>
		  				<td>
								<p>MLP TX highest vport status table timeout counter level achieved interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL/WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>24</td>
		  				<td><p>MlpTxW4RErr</p></td>
		  				<td>
								<p>MLP TX link wait for response error interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL/WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>23</td>
		  				<td><p>MlpTxRtyErr</p></td>
		  				<td>
								<p>MLP TX link retry failure event interrupt flag field.<br/><br/>SEVERITY: WARNING/FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>22</td>
		  				<td><p>MlpTxRtyWrn</p></td>
		  				<td>
								<p>MLP TX link retry event interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL/WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>21</td>
		  				<td><p>MlpTxVp0LenErr</p></td>
		  				<td>
								<p>MLP TX invalid vport0 data packet length interrupt flag field.<br/><br/>SEVERITY: FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>20</td>
		  				<td><p>MlpTxVpdropErr</p></td>
		  				<td>
								<p>MLP TX data/datn drop, due to invalid vport, interrupt flag field.<br/><br/>SEVERITY: WARNING/FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>19</td>
		  				<td><p>MlpTxIcsFluQErr</p></td>
		  				<td>
								<p>MLP TX cache flush QID request error interrupt flag field.<br/><br/>SEVERITY: FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>18</td>
		  				<td><p>MlpTxIcsRetQErr</p></td>
		  				<td>
								<p>MLP TX cache return QID request error interrupt flag field.<br/><br/>SEVERITY: FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>17</td>
		  				<td><p>MlpTxIcsNewQErr</p></td>
		  				<td>
								<p>MLP TX cache new QID request error interrupt flag field.<br/><br/>SEVERITY: FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>16</td>
		  				<td><p>MlpTxIcsQidAEmpty</p></td>
		  				<td>
								<p>MLP TX cache Queue ID almost empty interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>15</td>
		  				<td><p>MlpTxIcsQidEmpty</p></td>
		  				<td>
								<p>MLP TX cache Queue ID empty interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>14</td>
		  				<td><p>MlpTxIcsSidAEmpty</p></td>
		  				<td>
								<p>MLP TX cache Segment ID almost empty interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>13</td>
		  				<td><p>MlpTxIcsSidEmpty</p></td>
		  				<td>
								<p>MLP TX cache Segment ID empty interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL/WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>12</td>
		  				<td><p>MlpTxIcsUflow</p></td>
		  				<td>
								<p>MLP TX cache underflow interrupt flag field.<br/><br/>SEVERITY: FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>MlpTxIcsOflow</p></td>
		  				<td>
								<p>MLP TX cache overflow interrupt flag field.<br/><br/>SEVERITY: FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10</td>
		  				<td><p>MlpTxIcsInitDone</p></td>
		  				<td>
								<p>MLP TX cache initialization complete interrupt flag field.<br/>
								CLM Ethernet Packet Drop when Cache is almost full.
								<br/>SEVERITY: INFORMATIONAL</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>9</td>
		  				<td><p>MlpLinkEvent</p></td>
		  				<td>
								<p>MLP link event interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8</td>
		  				<td><p>PhyDfrmErrCrcEnet</p></td>
		  				<td>
								<p>PHY deframer MII level 2 framing CRC error interrupt flag field (ENET frame).<br/><br/>SEVERITY: INFORMATIONAL/WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>PhyDfrmErrCrcUsb</p></td>
		  				<td>
								<p>PHY deframer MII level 2 framing CRC error interrupt flag field (USB frame).<br/><br/>SEVERITY: WARNING/FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>PhyDfrmErrTout</p></td>
		  				<td>
								<p>IPF deframer timeout interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL/WARNING</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5</td>
		  				<td><p>PhyDfrmErrIpf</p></td>
		  				<td>
								<p>IPF deframer error interrupt flag field.<br/><br/>SEVERITY: WARNING/FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>4</td>
		  				<td><p>PhyDfrmErrFrm</p></td>
		  				<td>
								<p>PHY deframer framing error interrupt flag field.<br/><br/>SEVERITY: WARNING/FAILURE</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>RxStats</p></td>
		  				<td>
								<p>RxStats overflow interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2</td>
		  				<td><p>TxStats</p></td>
		  				<td>
								<p>TxStats overflow interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>RxStatsETR</p></td>
		  				<td>
								<p>RxStatsETR overflow interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>TxStatsETR</p></td>
		  				<td>
								<p>TxStatsETR overflow interrupt flag field.<br/><br/>SEVERITY: INFORMATIONAL</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MlpConfig0 Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MlpConfig0-0x20000214">MlpConfig0</a></h3>
	<p class="text">Offset: 0x20000214</p>
	<p class="text">MLP configuration register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:10</td>
		  				<td class="nameCol">RESERVED_BITS31_10</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>9:2</td>
		  				<td><p>TxVportEn[7:0]</p></td>
		  				<td>
								<p>Vport enable field.<br/><br/>0 : vport disable.<br/>1 : vport enabled.<br/><br/>Bit Mapping:<br/>TxVportEn[0] = Vport 0 (enabled by default)<br/>:<br/>TxVportEn[7] = Vport 7<br/><br/>Note: do not enable any non-zero vports before tx_enable is set, or in the same access as setting the tx_enable.<br/>Note: once enabled the MLP will attempt to establish a link automatically.  <br/>Note: once disabled the MLP will clear any packets in MLP cache and drop any further packets destined to the disabled vport.<br/>Note: it is possible to disable VPORT0, use great caution.</p>

							</td>
		  				<td>RW</td>
		  				<td>00000001</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>1</td>
		  				<td><p>TxEnable</p></td>
		  				<td>
								<p>MLP TX side enable.<br/><br/>0 : disabled<br/>1 : enabled<br/><br/>Note: do not enable any non-zero vports before tx_enable is set, or in the same access as setting the tx_enable.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>RxEnable</p></td>
		  				<td>
								<p>MLP RX side enable.<br/><br/>0 : disabled<br/>1 : enabled</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MlpConfig1 Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MlpConfig1-0x20000218">MlpConfig1</a></h3>
	<p class="text">Offset: 0x20000218</p>
	<p class="text">MLP configuration register 1.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31</td>
		  				<td class="nameCol">RESERVED_BIT31</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>30:27</td>
		  				<td><p>ToCntThresh[3:0]</p></td>
		  				<td>
								<p>MLP TX vport status table timeout counter level threshold field.<br/><br/>This field selects the level of the vport status table timeout counter field that will generate an interrupt.</p>

							</td>
		  				<td>RW</td>
		  				<td>4</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>26:23</td>
		  				<td><p>TxQidThresh[3:0]</p></td>
		  				<td>
								<p>MLP TX cache queue ID almost empty threshold field.<br/><br/>This field selects the number of dynamic QIDs that must remain available at all times.  This allows selection of the number of retriable packets in flight at the same time, since each retriable packet requires 1 dynamic QID for temporary storage.<br/><br/>Each unit represents 1 retriable packet:<br/>0000 : 15 simultaneous retriable packets in flight<br/>0001 : 14 simultaneous retriable packets in flight<br/>0010 : 13 simultaneous retriable packets in flight<br/>:<br/>1110 : 01 retriable packet in flight<br/>1111 : invalid (do not use)<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>22:15</td>
		  				<td><p>TxSidThresh[7:0]</p></td>
		  				<td>
								<p>MLP TX cache segment ID almost empty threshold field.<br/><br/>This field selects the amount of MLP TX cache space (in SIDs) required to allow the MLP TX to accept the next packet for transmission.  This SID level is set such that it will ensure space for a maximum sized data packet (1200bytes).<br/><br/>Each unit represents 32 bytes (1SID=32bytes):<br/>00100110 : 1216 bytes<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>38</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>14:7</td>
		  				<td><p>TxW4RThresh[7:0]</p></td>
		  				<td>
								<p>Wait for response threshold field.  <br/><br/>This field sets the wait for response timeout period for stats and required data acknowledgments. A timeout occurs some time shortly after the timeout period; therefore this limit is considered a "minimum" timeout.<br/><br/>Note: each unit of this field represents 1024 phy clock cycles.<br/><br/>0-1 : invalid (do not use)<br/>2   : minimum<br/>254 : maximum<br/>255 : invalid (do not use)<br/><br/>Optimal limit math:  (w4r_period/(1024/phy_clk_freq)) <br/>  - note: round up to guarantee minimum timeout period<br/>Actual minimum math: (tx_w4r_limit*(1/phy_clk_freq)*1024)<br/><br/>Example: GMII - if desired minimum w4r_period is 125us<br/>Optimal limit: 15.3<br/>Actual minimum (tx_w4r_limit=15): 122.9us <br/>Actual minimum (tx_w4r_limit=16): 131.1us <br/><br/>Example: MII  - if desired minimum w4r_period is 1ms<br/>Optimal limit: 24.4<br/>Actual minimum (tx_w4r_limit=24): 0.983ms <br/>Actual minimum (tx_w4r_limit=25): 1.024ms <br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>7</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>6:4</td>
		  				<td><p>TxW4RVpWatch[2:0]</p></td>
		  				<td>
								<p>Wait for response count vport select field.  This field selects a specific vport for which  to count the W4R interrupts.  This is count may differ from the total W4R interrupt generated in a multi-vport system.  <br/><br/>Note: the associated count is located in the TxStatsETR.MlpTxVpW4RErr field.<br/>Note: if this field is changed discard the first read of TxStatsETR.MlpTxVpW4RErr field.</p>

							</td>
		  				<td>RW</td>
		  				<td>1</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>3:0</td>
		  				<td><p>TxW4RLimit[3:0]</p></td>
		  				<td>
								<p>Wait for response limit field.<br/><br/>This field selects the number W4R events in a row permitted without indicating a loss of link. For example: a value of 3 will allow 3 W4R timeouts to occur without taking down the link, however on the 4th W4R timeout the link will be considered lost.<br/><br/>0    : INVALID - do not use<br/>1-15 : VALID<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>3</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the PhyConfig Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.PhyConfig-0x2000021C">PhyConfig</a></h3>
	<p class="text">Offset: 0x2000021C</p>
	<p class="text">PHY configuration register.  Special sequence instructions:<br/>1) set Clm.PhyConfig.PhyMode.<br/>2) set serial or parallel configuration options.<br/>- write register.<br/>3) IF using the parallel PHY: set Clm.PhyConfig.ParPhyRdy = 1.<br/>- write register.<br/><br/>Note: For the parallel PHY the Clm.PhyConfig.ParPhyRdy field must be a seperate write due to clock domain timing issues. The ready signal is synchronized and used to indicate that the other configuration fields are ready to be used.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31</td>
		  				<td class="nameCol">RESERVED_BITS31</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>30</td>
		  				<td><p>ParL2Frm</p></td>
		  				<td>
								<p>Parallel PHY ethernet level 2 framing enable field.  This field is must NOT be set "1" unless PhyIPFEn is also set "1".<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>29:22</td>
		  				<td><p>ParToutThresh[7:0]</p></td>
		  				<td>
								<p>This field selected the maximum number of PhyClks cycles where no incoming traffic is detected once a packet reception has started.  Lost EOF case.  On timeout the packet is capped to the MLP and a new SOF search begins.<br/><br/>Currently only supports (G)MII.  This value depends on L2F mode and presence of switches in system.  Set default for 128 clocks (direct connected l2f mode).<br/><br/>Note: each unit represents 32 PhyClks.  Set 0 for no limit.<br/>0   = disabled<br/>1   = 32 cycles <br/>4   = 128 cycles (default)<br/>255 = 8160 cycles<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>4</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>21:14</td>
		  				<td><p>ParFrmThresh[7:0]</p></td>
		  				<td>
								<p>Parallel PHY frame threshold.  This threshold determines the maximum number of bytes into an frame/transmission that a new packet will be allowed to begin in the same frame/transmission. <br/><br/>Note: each unit represents 4 payload bytes (does not include: pre,sfd,dmac,smac,etype and fcs) into the transmission.  Set 0 for no limit.<br/>0   = No limit<br/>16  = 64 bytes (minimum if L2 framing enabled)<br/>64  = 256 bytes (maximum if trying to avoid spanning frames)<br/>128 = 512 bytes<br/>255 = 1020 bytes<br/><br/>Note: Max MII frame = 1500 bytes.<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>64</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>13:9</td>
		  				<td><p>ParIdleThresh[4:0]</p></td>
		  				<td>
								<p>Parallel PHY idle threshold.  This threshold determines the maximum number of IDLEs injected into the data stream following a cache packet before closing the current MII frame. If a new cache frame destined for the same VPORT, and ParIpfPack is set, is ready to send before the IDLEs are complete the new cache frame will append to the current MII frame.<br/><br/>Half Duplex: N/A - (set/leave 0)<br/>Full Duplex (ParIpfPack == 0) : N/A - (set/leave 0)<br/>Full Duplex (ParIpfPack != 0) : Each unit represents PHY_CLKs of IDLEs.<br/>  0  = 000 IDLEs<br/>  1  = 008 IDLEs<br/>  31 = 248 IDLEs<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>8:7</td>
		  				<td><p>ParIfgMode[1:0]</p></td>
		  				<td>
								<p>Inter-frame gap mode select field. MII and GMII modes only.  This field allows selection of transmit bandwidth throttling options.  The IFG can be selected to be proportional to the previously transmitted frame size (PTFS - time tx_en is asserted).  In all cases the minimum IFG of 12 cycles is guaranteed, and for all frames under 64 bytes the IFG is set to 12 cycles.  The IFG for frames greater than or equal to 64 bytes is set according to the selected IFG mode:<br/><br/>00 - max 100% transmit - IFG = 12     cycles<br/>01 - max 88%  transmit - IFG = PTFS/4 cycles (for PTFS>64)<br/>10 - max 75%  transmit - IFG = PTFS/2 cycles (for PTFS>64)<br/>11 - max 50%  transmit - IFG = PTFS   cycles (for PTFS>64)</p>

							</td>
		  				<td>RW</td>
		  				<td>00</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6</td>
		  				<td><p>ParIpfPack</p></td>
		  				<td>
								<p>Parallel PHY IPF frame packing enable.<br/><br/>0 = Do not pack multiple frames within a MII frame.<br/>1 = Allow packing of multiple frames within a MII frame.<br/><br/>Packing allows multiple cache frames to occupy a MII frame.  A new cache frame may be added to a currently open MII frame as long as this bit is set, the ParFrmThresh has not yet been achieved, and the VPORT is the same as the previous VPORT.<br/><br/>Note: only valid for GMII/MII modes.<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>1</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5</td>
		  				<td><p>ParRedBit</p></td>
		  				<td>
								<p>Parallel PHY reduced pin interface, also known as double data rata "DDR", mode selection field.<br/><br/>0 = Normal data rate.<br/>1 = Double data rate.<br/><br/>Note: Not valid with CLEI1.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>4:1</td>
		  				<td><p>ParMode[3:0]</p></td>
		  				<td>
								<p>Parallel PHY mode selection field.  This field indicates the PHY mode of operation and/or the PHY speed of operation:<br/><br/>0000 = CLEI8<br/>0001 = CLEI4<br/>0010 = CLEI2<br/>0011 = CLEI1<br/>0100 = MII<br/>0101 = GMII<br/>0110 = TBI<br/>0111 = Legacy TBI<br/>1000 = TBI with Ethernet Framing<br/>1001 = Legacy TBI with Ethernet Framing<br/>1010 = Reserved (do not use)<br/>1011 = Reserved (do not use)<br/>1100 = Reserved (do not use)<br/>1101 = Reserved (do not use)<br/>1110 = Reserved (do not use)<br/>1111 = Reserved (do not use)<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>0101</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>ParReady</p></td>
		  				<td>
								<p>Parallel PHY indication field.  Once all parallel PHY configuration fields have been set appropriately this field is asserted to indicate that the PRX and PTX modules can sample the configuration fields.<br/><br/>Note: Only assert this field following a reset.  This field is not self clearing and there is no need to clear this field once set.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the EtherType Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.EtherType-0x20000220">EtherType</a></h3>
	<p class="text">Offset: 0x20000220</p>
	<p class="text">Level 2 Framing EtherType</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>Eco</p></td>
		  				<td>
								<p>ECO Enable to fix MII IFG<br><br>
NOTE: Write Only for GE ASIC</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
						<tr>
        	  	<td class="bitsCol">30:28</td>
		  				<td class="nameCol">RESERVED_BITS30_28</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>27:16</td>
		  				<td><p>Ifg[11:0]</p></td>
		  				<td>
								<p>When ECO is enabled the IFG for packets with less than 64 payload bytes is:<br>
(Ifg + 2) * CTM PHY clock period (For MII spec compliance: (22 + 2) * 40 = 960ns).<br>
When PhyConfig.ParIfgMode is 0 the programmed IFG applies to all packets.<br><br>
NOTE: Write Only for GE ASIC</p>

							</td>
		  				<td>RW</td>
		  				<td>000</td>
		  				<td>hexadecimal</td>
					</tr>
        		<tr>
        	  	<td>15:0</td>
		  				<td><p>Type[15:0]</p></td>
		  				<td>
								<p>Level 2 Framing EtherType<br/><br/>MAC Frame: PRE(7), SFD(1), DSTMAC(6), SRCMAC(6), EtherType(2), PAYLOAD(46-1500), FCS(4)<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>ffff</td>
		  				<td>hexadecimal</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MacSrc Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MacSrcLsw-0x20000224">MacSrcLsw</a></h3>
	<p class="text">Offset: 0x20000224</p>
	<p class="text">Source MAC Address (least significant 24 bits).  As in "local address"</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:24</td>
		  				<td class="nameCol">RESERVED_BITS31_24</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>23:0</td>
		  				<td><p>Src[23:0]</p></td>
		  				<td>
								<p>Source MAC Address (least significant 24 bits)<br/><br/>NOTE: MAC address = 48bits; ICRON_OUI(0x001b13) represents the most significant 24bits.<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>000000</td>
		  				<td>hexadecimal</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MacSrc Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MacSrcMsw-0x20000228">MacSrcMsw</a></h3>
	<p class="text">Offset: 0x20000228</p>
	<p class="text">Source MAC Address (most significant 24 bits).  As in "local address"</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:24</td>
		  				<td class="nameCol">RESERVED_BITS31_24</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>23:0</td>
		  				<td><p>Src[23:0]</p></td>
		  				<td>
								<p>Source MAC Address (most significant 24 bits)<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>001b13</td>
		  				<td>hexadecimal</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MacDst Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MacDst-0x2000022C">MacDst</a></h3>
	<p class="text">Offset: 0x2000022C</p>
	<p class="text">Destination MAC Address (least significant 24 bits) and LEX Destination MAC table control fields.  As in "remote address".<br/><br/>REX NOTE: Only the Msw field of the register is required. <br/>LEX NOTE: Software must configure the LEX Destination MAC table appropriately when L2 framing enabled.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:30</td>
		  				<td class="nameCol">RESERVED_BITS31_30</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>29</td>
		  				<td><p>Go</p></td>
		  				<td>
								<p>LEX ONLY FIELD: Destination MAC table access go field.  Set '1' to initiate an access.  This field is cleared once access is complete.</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>28</td>
		  				<td><p>WNR</p></td>
		  				<td>
								<p>LEX ONLY FIELD: Destination MAC table read/write select field.<br/><br/>0 = Read<br/>1 = Write<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>27:25</td>
		  				<td><p>Vport[2:0]</p></td>
		  				<td>
								<p>LEX ONLY FIELD: Destination MAC table Vport index field.  This field selects the Vport for which the MAC will be or is associated with.<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>24</td>
		  				<td><p>Multi</p></td>
		  				<td>
								<p>LEX ONLY FIELD: Destination MAC address is MultiCast.  Setting this field in the LEX MAC address table will force the multicast bit of the destination MAC address field to be set during transmission.  Each VPORT can be individually configured to send as Uni or MultiCast.<br/><br/>0 = UniCast<br/>1 = MultiCast<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>23:0</td>
		  				<td><p>Dst[23:0]</p></td>
		  				<td>
								<p>Destination MAC Address (least significant 24 bits).<br/><br/>REX NOTE: this field is set with the LEX MAC Address.<br/>LEX NOTE: this field is set with the REX MAC Address for the current access.  Only valid when WNR=1.<br/><br/>NOTE: MAC address = 48bits; ICRON_OUI(0x001b13) represents the most significant 24bits.<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>000000</td>
		  				<td>hexadecimal</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MacSrc Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MacDstMsw-0x20000230">MacDstMsw</a></h3>
	<p class="text">Offset: 0x20000230</p>
	<p class="text">Source MAC Address (most significant 24 bits).  As in "remote address"</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:24</td>
		  				<td class="nameCol">RESERVED_BITS31_24</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>23:0</td>
		  				<td><p>Dst[23:0]</p></td>
		  				<td>
								<p>Destination MAC Address (most significant 24 bits)<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>001b13</td>
		  				<td>hexadecimal</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MacRdDst Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MacRdDst-0x20000234">MacRdDstLsw</a></h3>
	<p class="text">Offset: 0x20000234</p>
	<p class="text">LEX ONLY REGISTER: Destination MAC Address table read result (least significant 24 bits).</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:25</td>
		  				<td class="nameCol">RESERVED_BITS31_25</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>24</td>
		  				<td><p>Multi</p></td>
		  				<td>
								<p>LEX ONLY FIELD: Destination MAC address is MultiCast read result.  <br/><br/>0 = UniCast<br/>1 = MultiCast<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>23:0</td>
		  				<td><p>Dst[23:0]</p></td>
		  				<td>
								<p>LEX ONLY FIELD: Destination MAC Address table read result (least significant 24 bits).<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>R</td>
		  				<td>000000</td>
		  				<td>hexadecimal</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MacSrc Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MacRdDstMsw-0x20000238">MacRdDstMsw</a></h3>
	<p class="text">Offset: 0x20000238</p>
	<p class="text">Source MAC Address (most significant 24 bits).  As in "remote address"</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:24</td>
		  				<td class="nameCol">RESERVED_BITS31_24</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>23:0</td>
		  				<td><p>Dst[23:0]</p></td>
		  				<td>
								<p>Destination MAC Address (most significant 24 bits)<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>001b13</td>
		  				<td>hexadecimal</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the TxStats Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.TxStats-0x2000023C">TxStats</a></h3>
	<p class="text">Offset: 0x2000023C</p>
	<p class="text">Statistic counter for transmission register.<br/><br/>Note: All fields are cleared on read of this register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31:28</td>
		  				<td><p>TagSel[3:0]</p></td>
		  				<td>
								<p>Transmitted frame count tagtype select field.  See the frame structure document description sheet for definitions of tagtypes.  This allows counting only a selected frame type.<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>0000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>27</td>
		  				<td><p>TagTypeOflow</p></td>
		  				<td>
								<p>Transmitted tagtype frame counter overflow field.  This field is asserted when the Clm.TxStats.TagType counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>26:16</td>
		  				<td><p>TagType[10:0]</p></td>
		  				<td>
								<p>Transmitted tagtype frame count field.  This field is incremented every time the CLM has determined that a frame with tagtype matching CLM.RxStats.TagSel has been transmitted.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>15</td>
		  				<td><p>AllTypeOflow</p></td>
		  				<td>
								<p>Transmitted alltype frame counter overflow field.  This field is asserted when the Clm.TxStats.AllType counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>14:0</td>
		  				<td><p>AllType[14:0]</p></td>
		  				<td>
								<p>Transmitted alltype frame count field.  This field is incremented every time the CLM has determined that a frame with any tagtype has been transmitted.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the RxStats Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.RxStats-0x20000240">RxStats</a></h3>
	<p class="text">Offset: 0x20000240</p>
	<p class="text">Statistic counter for reception register.<br/><br/>Note: All fields are cleared on read of this register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31:28</td>
		  				<td><p>TagSel[3:0]</p></td>
		  				<td>
								<p>Received frame count tagtype select field.  See the frame structure document description sheet for definitions of tagtypes.  This allows counting only a selected frame type.<br/><br/>FALSE PATH FIELD</p>

							</td>
		  				<td>RW</td>
		  				<td>0000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>27</td>
		  				<td><p>TagTypeOflow</p></td>
		  				<td>
								<p>Received tagtype frame counter overflow field.  This field is asserted when the Clm.RxStats.TagType counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>26:16</td>
		  				<td><p>TagType[10:0]</p></td>
		  				<td>
								<p>Received tagtype frame count field.  This field is incremented every time the CLM has determined that a frame with tagtype matching CLM.RxStats.TagSel has been received.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>15</td>
		  				<td><p>AllTypeOflow</p></td>
		  				<td>
								<p>Received alltype frame counter overflow field.  This field is asserted when the Clm.RxStats.AllType counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>14:0</td>
		  				<td><p>AllType[14:0]</p></td>
		  				<td>
								<p>Received alltype frame count field.  This field is incremented every time the CLM has determined that a frame with any tagtype has been received.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the TxStatsETR Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.TxStatsETR-0x20000244">TxStatsETR</a></h3>
	<p class="text">Offset: 0x20000244</p>
	<p class="text">Transmit statistic counters for errors/timeouts/retries register.<br/><br/>Note: All fields are cleared on read of this register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:24</td>
		  				<td class="nameCol">RESERVED_BITS31_24</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>23:20</td>
		  				<td><p>MlpTxToCntLvl[3:0]</p></td>
		  				<td>
								<p>MLP TX highest vport status table timeout counter level achieved field.  This field represents the highest vport status table timeout counter level achieved since the last read of this register.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>19</td>
		  				<td><p>MlpTxVpW4RErrOflow</p></td>
		  				<td>
								<p>MLP TX link wait for response error event counter overflow field.  This field is asserted when the Clm.StatCntETR.MlpTxVpW4RErr counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>18:16</td>
		  				<td><p>MlpTxVpW4RErr[2:0]</p></td>
		  				<td>
								<p>MLP TX link wait for response error event counter (vport specific) field.  This field is incremented when a wait for response event has occurred to a specified vport.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>15</td>
		  				<td><p>MlpTxW4RErrOflow</p></td>
		  				<td>
								<p>MLP TX link wait for response error event counter overflow field.  This field is asserted when the Clm.StatCntETR.MlpTxW4RErr counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>14:12</td>
		  				<td><p>MlpTxW4RErr[2:0]</p></td>
		  				<td>
								<p>MLP TX link wait for response error event counter field.  <br/><br/>Note: this field only increments with the interrupt source pulse.  Please see associated interrupt source field for rules regarding generation.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>MlpTxRtyErrOflow</p></td>
		  				<td>
								<p>MLP TX link retry failure event counter overflow field.  This field is asserted when the Clm.StatCntETR.MlpTxRtyErr counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10:8</td>
		  				<td><p>MlpTxRtyErr[2:0]</p></td>
		  				<td>
								<p>MLP TX link retry failure event counter field.  <br/><br/>Note: this field only increments with the interrupt source pulse.  Please see associated interrupt source field for rules regarding generation.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>MlpTxRtyWrnOflow</p></td>
		  				<td>
								<p>MLP TX link retry event counter overflow field. This field is asserted when the Clm.TxStatETR.MlpTxRtyWrn counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6:4</td>
		  				<td><p>MlpTxRtyWrn[2:0]</p></td>
		  				<td>
								<p>MLP TX link retry event counter field.  <br/><br/>Note: this field only increments with the interrupt source pulse.  Please see associated interrupt source field for rules regarding generation.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>MlpTxVpDropErrOflow</p></td>
		  				<td>
								<p>MLP TX data/datn drop, due to invalid vport, event counter overflow field.  This field is asserted when the Clm.TxStatETR.MlpTxVpDropWrn counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2:0</td>
		  				<td><p>MlpTxVpDropErr[2:0]</p></td>
		  				<td>
								<p>MLP TX data/datn drop, due to invalid vport, event counter field.  <br/><br/>Note: this field only increments with the interrupt source pulse.  Please see associated interrupt source field for rules regarding generation.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the RxStatsETR Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.RxStatsETR-0x20000248">RxStatsETR</a></h3>
	<p class="text">Offset: 0x20000248</p>
	<p class="text">Statistic counters for errors/timeouts/retries register.<br/><br/>Note: All fields are cleared on read of this register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>PhyDfrmErrFrmOflow</p></td>
		  				<td>
								<p>PHY deframer framing error event counter overflow field. This field is asserted when the Clm.StatCntETR.PhyDfrmErrFrm counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>30:28</td>
		  				<td><p>PhyDfrmErrFrm[2:0]</p></td>
		  				<td>
								<p>PHY deframer framing error event counter field.  This field is incremented every time the PHY deframer has determined that a framing error in the reception stream has occurred.  In this case the PHY deframer will flush the remainder of the transmission.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>27</td>
		  				<td><p>PhyDfrmErrCrcUsbOflow</p></td>
		  				<td>
								<p>PHY deframer MII level 2 framing CRC error event counter overflow field (USB frames).  This field is asserted when the Clm.RxStatsETR.PhyDfrmErrCrc counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>26:24</td>
		  				<td><p>PhyDfrmErrCrcUsb[2:0]</p></td>
		  				<td>
								<p>PHY deframer MII level 2 framing CRC error event counter field (USB frames).  This field is incremented every time the deframer has detected a reception error in the MII level 2 frame.<br/><br/>Note: only valid when ParL2Frm = 1</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>23</td>
		  				<td><p>PhyDfrmErrIpfOflow</p></td>
		  				<td>
								<p>PHY IPF deframer error event counter overflow field.  This field is asserted when the Clm.RxStatsETR.PhyDfrmErrIpf counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>22:20</td>
		  				<td><p>PhyDfrmErrIpf[2:0]</p></td>
		  				<td>
								<p>PHY IPF deframer error event counter field.  This field is incremented every time the IPF deframer has detected an error in the incoming reception stream.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>19</td>
		  				<td><p>PhyDfrmErrToutOflow</p></td>
		  				<td>
								<p>PHY IPF deframer timeout event counter overflow field.  This field is asserted when the Clm.RxStatsETR.PhyDfrmErrTout counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>18:16</td>
		  				<td><p>PhyDfrmErrTout[2:0]</p></td>
		  				<td>
								<p>PHY IPF deframer timeout event counter field.  This field is incremented every time the IPF deframer has detected an timeout in the incoming reception stream.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>15</td>
		  				<td><p>MlpRxSeqErrOflow</p></td>
		  				<td>
								<p>MLP RX sequence error event counter overflow field. This field is asserted when the Clm.RxStatsETR.MlpRxSeqErr counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>14:12</td>
		  				<td><p>MlpRxSeqErr[2:0]</p></td>
		  				<td>
								<p>MLP RX sequence error event counter field.  <br/><br/>Note: this field only increments with the interrupt source pulse.  Please see associated interrupt source field for rules regarding generation.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>11</td>
		  				<td><p>MlpRxPldErrOflow</p></td>
		  				<td>
								<p>MLP RX payload crc validation failure event counter overflow field.  This field is asserted when the Clm.RxStatsETR.MlpRxPldErr counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>10:8</td>
		  				<td><p>MlpRxPldErr[2:0]</p></td>
		  				<td>
								<p>MLP RX payload crc validation failure event counter field.  <br/><br/>Note: this field only increments with the interrupt source pulse.  Please see associated interrupt source field for rules regarding generation.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>7</td>
		  				<td><p>MlpRxHdrErrOflow</p></td>
		  				<td>
								<p>MLP RX header crc validation failure event counter overflow field.  This field is asserted when the Clm.RxStatsETR.MlpRxHdrErr counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>6:4</td>
		  				<td><p>MlpRxHdrErr[2:0]</p></td>
		  				<td>
								<p>MLP RX header crc validation failure event counter field.  This field is incremented when a crc failure has been detected in the MLP header.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>3</td>
		  				<td><p>MlpRxFcDropErrOflow</p></td>
		  				<td>
								<p>MLP RX packet dropped, due to local flow control condition, event counter overflow field.  This field is asserted when the Clm.RxStatsETR.MlpTxFcDrop counter field overflows. <br/><br/>0 = counter has not overflowed.<br/>1 = counter has overflowed.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2:0</td>
		  				<td><p>MlpRxFcDropErr[2:0]</p></td>
		  				<td>
								<p>MLP RX packet dropped, due to local flow control condition, event counter field.  <br/><br/>Note: this field only increments with the interrupt source pulse.  Please see associated interrupt source field for rules regarding generation.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MlpStatus Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MlpStatus-0x2000024C">MlpStatus</a></h3>
	<p class="text">Offset: 0x2000024C</p>
	<p class="text">MLP status register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:8</td>
		  				<td class="nameCol">RESERVED_BITS31_8</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>7:1</td>
		  				<td><p>VpLinkStatus[6:0]</p></td>
		  				<td>
								<p>Vport link status field.<br/><br/>0 : vport link not established or lost.<br/>1 : vport link established.<br/><br/>Bit Mapping:<br/>VpLinkStatus[0] = vport 1<br/>:<br/>VpLinkStatus[6] = vport 7<br/><br/>Note: vport 0 does not have a link status</p>

							</td>
		  				<td>R</td>
		  				<td>0000000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>0</td>
		  				<td><p>IcsInitDone</p></td>
		  				<td>
								<p>Cache initialization complete status field.<br/><br/>0 : MLP cache not initialized.<br/>1 : MLP cache initialized.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MlpIcsStatus Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MlpIcsStatus-0x20000250">MlpIcsStatus</a></h3>
	<p class="text">Offset: 0x20000250</p>
	<p class="text">MLP cache status register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
        		<tr>
        	  	<td>31</td>
		  				<td><p>QidEmpty</p></td>
		  				<td>
								<p>Cache Queue ID (QID) empty (0 SIDs remain) indicator field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>30</td>
		  				<td><p>QidAEmpty</p></td>
		  				<td>
								<p>Cache Queue ID (QID) almost empty (l or 0 SIDs remain) indicator field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>29:25</td>
		  				<td><p>QidFreeCnt[4:0]</p></td>
		  				<td>
								<p>Cache Queue ID (QID) free count field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>24:20</td>
		  				<td><p>QidFreeCntLow[4:0]</p></td>
		  				<td>
								<p>Cache Queue ID (QID) free count low point since last read of this register field.<br/><br/>Note: This field is cleared on read of this register.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>19</td>
		  				<td><p>SidEmpty</p></td>
		  				<td>
								<p>Cache Segment ID (SID) empty (0 SIDs remain) indicator field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>18</td>
		  				<td><p>SidAEmpty</p></td>
		  				<td>
								<p>Cache Segment ID (SID) almost empty (l or 0 SIDs remain) indicator field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>17:9</td>
		  				<td><p>SidFreeCnt[8:0]</p></td>
		  				<td>
								<p>Cache Segment ID (SID) free count field.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>
        		<tr>
        	  	<td>8:0</td>
		  				<td><p>SidFreeCntLow[8:0]</p></td>
		  				<td>
								<p>Cache Segment ID (SID) free count low point since last read of this register field.<br/><br/>Note: This field is cleared on read of this register.</p>

							</td>
		  				<td>R</td>
		  				<td>0</td>
		  				<td>unsigned</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<!--
		**********************************************************************
	 	Description of the MlpVpHold Register and it's BitFields
		**********************************************************************
	-->
	<h3><a name="Clm.MlpVpHold-0x20000254">MlpVpHold</a></h3>
	<p class="text">Offset: 0x20000254</p>
	<p class="text">MLP error/warning vport hold register.</p>

	<table class="bitFields">
		<colgroup span="5">
		<col class="bitsCol"/>
		<col class="nameCol"/>
		<col class="descCol"/>
		<col class="rwCol"/>
		<col class="rstCol"/>
		<col class="valTypeCol"/>
				</colgroup>
				<thead>
	 			<tr>
		 			<th>Bits</th>
	 				<th>Field Name</th>
					<th>Description</th>
					<th>R/W</th>
	 				<th>Reset Value</th>
	 				<th>Value Type</th>
	    	</tr>
				</thead>
				<tbody>
						<tr>
        	  	<td class="bitsCol">31:21</td>
		  				<td class="nameCol">RESERVED_BITS31_21</td>
		  				<td class="descCol">N/A</td>
		  				<td class="rwCol">N/A</td>
		  				<td class="rstCol">N/A</td>
		  				<td class="valTypeCol">N/A</td>
						</tr>
        		<tr>
        	  	<td>20:18</td>
		  				<td><p>MlpRxPldErr[2:0]</p></td>
		  				<td>
								<p>MLP RX payload crc error vport hold field.  When a Clm.IntSrc.MlpRxPldErr event occurs the associated vport is held in this field.  <br/><br/>Note: In cases of multiple events only the first vport is held in this field.  Reading this register will allow vport to be captured/updated for next event.</p>

							</td>
		  				<td>R</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>17:15</td>
		  				<td><p>MlpRxSeqErr[2:0]</p></td>
		  				<td>
								<p>MLP RX receive sequence error vport hold field.  When a Clm.IntSrc.MlpRxSeqErr event occurs the associated vport is held in this field.  <br/><br/>Note: In cases of multiple events only the first vport is held in this field.  Reading this register will allow vport to be captured/updated for next event.</p>

							</td>
		  				<td>R</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>14:12</td>
		  				<td><p>MlpRxFcDropErr[2:0]</p></td>
		  				<td>
								<p>MLP RX packet dropped vport hold field.  When a Clm.IntSrc.MlpRxFcDropErr event occurs the associated vport is held in this field.  <br/><br/>Note: In cases of multiple events only the first vport is held in this field.  Reading this register will allow vport to be captured/updated for next event.</p>

							</td>
		  				<td>R</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>11:9</td>
		  				<td><p>MlpTxW4RErr[2:0]</p></td>
		  				<td>
								<p>MLP TX link wait for response error vport hold field. When a Clm.IntSrc.MlpTxW4RErr event occurs the associated vport is held in this field.  <br/><br/>Note: In cases of multiple events only the first vport is held in this field.  Reading this register will allow vport to be captured/updated for next event.</p>

							</td>
		  				<td>R</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>8:6</td>
		  				<td><p>MlpTxRtyErr[2:0]</p></td>
		  				<td>
								<p>MLP TX link retry failure event vport hold field. When a Clm.IntSrc.MlpTxRtyErr event occurs the associated vport is held in this field.  <br/><br/>Note: In cases of multiple events only the first vport is held in this field.  Reading this register will allow vport to be captured/updated for next event.</p>

							</td>
		  				<td>R</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>5:3</td>
		  				<td><p>MlpTxRtyWrn[2:0]</p></td>
		  				<td>
								<p>MLP TX link retry event vport hold field. When a Clm.IntSrc.MlpTxRtyWrn event occurs the associated vport is held in this field.  <br/><br/>Note: In cases of multiple events only the first vport is held in this field.  Reading this register will allow vport to be captured/updated for next event.</p>

							</td>
		  				<td>R</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>
        		<tr>
        	  	<td>2:0</td>
		  				<td><p>MlpTxVpDropErr[2:0]</p></td>
		  				<td>
								<p>MLP TX packet dropped vport hold field.  When a Clm.IntSrc.MlpTxVpDrop event occurs the associated vport is held in this field.  <br/><br/>Note: In cases of multiple events only the first vport is held in this field.  Reading this register will allow vport to be captured/updated for next event.</p>

							</td>
		  				<td>R</td>
		  				<td>000</td>
		  				<td>binary</td>
					</tr>

			</tbody>
      </table>
			<p><a class="back" href="#Register_Summary">Back to Register Summary Table</a></p>
	<table class="footer">
	<tr>
		<td><p>Clm Memory Mapped Registers</p></td>
		<td><p align="center">&copy;2009 Productivity Design Tools Inc. (PDTi)</p></td>
		<td><p align="right">Generated using <a href="http://www.productive-eda.com">PDTi</a> SpectaReg.</p></td>
	</tr>
	</table>
	</body>
</html>
