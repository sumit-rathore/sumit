///////////////////////////////////////////////////////////////////////////////
///
///   Icron Technology Corporation - Copyright 2012
///
///
///   This source file and the information contained in it are confidential and
///   proprietary to Icron Technology Corporation. The reproduction or
///   disclosure, in whole or in part, to anyone outside of Icron without the
///   written approval of a Icron officer under a Non-Disclosure Agreement, or
///   to any employee of Icron who has not previously obtained written
///   authorization for access from the individual responsible for the source
///   code, will have a significant detrimental effect on Icron and is
///   expressly prohibited.
///
///////////////////////////////////////////////////////////////////////////////
//
//!   @file  - mac.c
//
//!   @brief - performs the MAC operation on the Atmel chip
//
//!   @note  - The MAC is generated by the SHA-256 digest of the message:
//              32bytes: key[keyID]
//              32bytes: Challenge
//              1 byte : opCode (always 0x08)
//              1 byte : Mode (in our case use MAC_MODE define)
//              2 bytes: Param2 (in our case use PARAM2 defines)
//              11bytes: zeroes
//              1 byte : SN[8] (always 0xEE)
//              4 bytes: zeroes
//              2 bytes: SN[0:1] (always 0x01 0x23)
//              2 bytes: zeroes
//
//             MAC stands for Message Authentication Code, and is a SHA-256
//
//             The process for this operation is
//              1) Submit operation to Atmel chip (HW operation)
//              2) On completion of operation on Atmel chip (HW operation)
//                  a) save Atmel digest
//                  b) start calculating the MAC in SW idle task
//              3) Once SW idle task has finished calculating MAC
//                  a) compare result to the Atmel chip
//                  b) stop idle task
//                  c) call completion handler
//
///////////////////////////////////////////////////////////////////////////////

/***************************** Included Headers ******************************/
#include "atmel_crypto_loc.h"

/************************ Defined Constants and Macros ***********************/
#define MAC_OPCODE 0x08
#define MAC_MODE 0x04 // use challenge + data slot
#define PARAM2_LSB 0x00 // keyID 0
#define PARAM2_MSB 0x00 // set to zero

#define MESSAGE_SIZE (ATMEL_MAC_SECRET_KEY_SIZE+ATMEL_MAC_CHALLENGE_SIZE+sizeof(messageTail))

/******************************** Data Types *********************************/
struct macStatus {
    const uint8 * secret;       // NOTE: pointer is zeroed on completion
                                // This is an indication if a MAC is in progress
    const uint8 * challenge;
    void (*completionHandler)(boolT success);
    TASKSCH_TaskT macTask;
    uint8 digest[SHA256_DIGEST_SIZE];
};

/***************************** Local Variables *******************************/

// The final part of the message for the SHA-256 digest
// SEE Atmel datasheet section 8.8
static const uint8 messageTail[] =
{
    MAC_OPCODE,
    MAC_MODE,
    PARAM2_LSB, PARAM2_MSB,
    0,0,0,0,0,0,0,0,
    0,0,0,
    0xEE,
    0,0,0,0,
    0x01,0x23,
    0,0
};

static struct macStatus macState;

/************************ Local Function Prototypes **************************/
static void atmel_doneHwMac(uint8 * data, uint8 dataSize, void * userPtr) __attribute__((section(".ftext")));
static void atmel_doSwMac(TASKSCH_TaskT task, uint32 taskArg);

static void atmel_doSwMacFinish(struct macStatus * pMacState,
#ifdef _ATMEL_MEASURE_MATH_FUNCTIONS_TIME
        const LEON_TimerValueT startTime,
#endif
        boolT digestsMatch) __attribute__((noinline, section(".ftext")));

/************************** Function Definitions *****************************/

/**
* FUNCTION NAME: _ATMEL_macInit()
*
* @brief  - Initialization function
*
* @return - void
*
* @note   -
*
*/
void _ATMEL_macInit(void)
{
    macState.macTask = TASKSCH_InitTask(
        &atmel_doSwMac,
        CAST(&macState, struct macStatus *, uint32), //uint32 taskArg,
        TRUE, //boolT allowInterrupts,
        TASKSCH_ATMEL_TASK_PRIORITY);
}

/**
* FUNCTION NAME: ATMEL_runMac()
*
* @brief  - Public API to run a MAC calculation against the Atmel chip
*
* @return - TRUE if operation was submitted, FALSE otherwise
*
* @note   - See Atmel datasheet for details of this operation
*
*           This starts the HW operation, see top of file for process
*/
boolT ATMEL_runMac
(
    const uint8 secretKey[ATMEL_MAC_SECRET_KEY_SIZE],
    const uint8 challenge[ATMEL_MAC_CHALLENGE_SIZE],
    void (*completionHandler)(boolT success)
)
{
    boolT ret;

    // this should only ever be called once
    // we will prevent it from being called while processing
    iassert_ATMEL_CRYPTO_COMPONENT_0(macState.secret == NULL, RUN_MAC_CALLED_WHILE_IN_PROGRESS);

    ilog_ATMEL_CRYPTO_COMPONENT_3(ILOG_DEBUG, RUN_MAC_CALLED, (uint32)secretKey, (uint32)challenge, (uint32)completionHandler);

    ret = _ATMEL_submitI2cOperation(
                MAC_OPCODE,
                MAC_MODE,
                PARAM2_LSB + (PARAM2_MSB << 8),
                ATMEL_MAC_CHALLENGE_SIZE,       // writeDataSize,
                challenge,                      // writeData,
                SHA256_DIGEST_SIZE,             // readDataSize,
                &atmel_doneHwMac,
                &macState, /* void * userPtr */
                36 /* operationExecutionTime */);

    if (ret)
    {
        // Operation was submitted
        // Save the necessary state of this transaction
        macState.secret = secretKey;
        macState.challenge = challenge;
        macState.completionHandler = completionHandler;
    }

    return ret;
}


/**
* FUNCTION NAME: atmel_doneHwMac()
*
* @brief  - Continuation function called when the Atmel chip operation has completed
*
* @return - void
*
* @note   - Saves the SHA-256 digest & starts an idle task to verify the digest
*
*/
static void atmel_doneHwMac
(
    uint8 * data, uint8 dataSize,   // Data from the Atmel chip
    void * userPtr                  // address of macState
)
{
    struct macStatus * pMacState = userPtr;

    ilog_ATMEL_CRYPTO_COMPONENT_3(ILOG_DEBUG, HW_MAC_DONE, (uint32)data, dataSize, (uint32)userPtr);

    // Check for valid args
    iassert_ATMEL_CRYPTO_COMPONENT_3(
            (data != NULL) && (dataSize == SHA256_DIGEST_SIZE),
            HW_MAC_DONE_INVALID_ARGS, (uint32)data, dataSize, (uint32)userPtr);

    // save the digest for comparison with our SW digest
    memcpy(pMacState->digest, data, SHA256_DIGEST_SIZE);

    // Start the task to calculate the SW digest
    TASKSCH_StartTask(pMacState->macTask);
}


/**
* FUNCTION NAME: atmel_doSwMac()
*
* @brief  - idle task to calculate the SHA-256 & verify against the Atmel result
*
* @return - void
*
* @note   - INTERRUPTS ARE ENABLED!!!!!
*
*/
static void atmel_doSwMac
(
    TASKSCH_TaskT task,
    uint32 taskArg      // address of macState
)
{
    struct macStatus * pMacState = CAST(taskArg, uint32, struct macStatus *);
    uint8 message[MESSAGE_SIZE];
    uint8 swDigest[SHA256_DIGEST_SIZE];
    uint8 index;
    boolT digestsMatch;

#ifdef _ATMEL_MEASURE_MATH_FUNCTIONS_TIME
    const LEON_TimerValueT startTime = LEON_TimerRead();
#endif

    // build message
    memcpy( &message[0],
            pMacState->secret,
            ATMEL_MAC_SECRET_KEY_SIZE);
    memcpy( &message[ATMEL_MAC_SECRET_KEY_SIZE],
            pMacState->challenge,
            ATMEL_MAC_CHALLENGE_SIZE);
    memcpy( &message[ATMEL_MAC_SECRET_KEY_SIZE+ATMEL_MAC_CHALLENGE_SIZE],
            messageTail,
            sizeof(messageTail));

    // Do the SHA-256!!!
    sha256(message, MESSAGE_SIZE, swDigest);

    // do a memcmp (it would be nice if ibase had this function)
    digestsMatch = TRUE;
    for (index = 0; index < SHA256_DIGEST_SIZE; index++)
    {
        // NOTE: REMEMBER IRQS ARE ENABLED, NO LOGGING!!!!
        if (swDigest[index] == pMacState->digest[index])
        {
            // bytes match :)
        }
        else
        {
            // bytes differ :(
            digestsMatch = FALSE;
        }
    }

    // Call a helper function to process the result
    atmel_doSwMacFinish(    pMacState,
#ifdef _ATMEL_MEASURE_MATH_FUNCTIONS_TIME
                            startTime,
#endif
                            digestsMatch);
}


/**
* FUNCTION NAME: atmel_doSwMacFinish()
*
* @brief  - Process the result of SHA-256 verification
*
* @return - void
*
* @note   -
*
*/
static void atmel_doSwMacFinish
(
    struct macStatus * pMacState,
#ifdef _ATMEL_MEASURE_MATH_FUNCTIONS_TIME
    const LEON_TimerValueT startTime,
#endif
    boolT digestsMatch
)
{
    // Critical section.  Lock out interrupts
    irqFlagsT flags = LEON_LockIrq();

    // Mark the operation as not in progress
    pMacState->secret = NULL;

    // How long did this take
#ifdef _ATMEL_MEASURE_MATH_FUNCTIONS_TIME
    ilog_ATMEL_CRYPTO_COMPONENT_2(ILOG_MINOR_EVENT, SW_MAC_DONE, digestsMatch, LEON_TimerCalcUsecDiff(startTime, LEON_TimerRead()));
#endif

    // Stop the task from running again
    TASKSCH_StopTask(pMacState->macTask);

    // Inform the caller that the MAC operation is complete
    (*pMacState->completionHandler)(digestsMatch);

    LEON_UnlockIrq(flags);
}

